{
  "Metadata": {
    "Title": "SPIR-V Specification (Provisional)",
    "Author": "John Kessenich, LunarG; Boaz Ouriel, Intel",
    "Revnumber": "version 0.99, revision 29 in progress",
    "LastUpdate": "Last updated 2015-02-19 18:30:13 MST"
  },
  "OpCodes": [
    {
      "Name": "OpNop",
      "Description": "<a id=\"OpNop\"></a><strong>OpNop</strong><br />\n<br />\nUse is invalid.",
      "DescriptionPlain": "OpNop\n\nUse is invalid.",
      "Category": "Miscellaneous",
      "Capabilities": [],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpUndef",
      "Description": "<a id=\"OpUndef\"></a><strong>OpUndef</strong><br />\n<br />\nMake an <a href=\"#Intermediate\">intermediate</a> object with no initialization.<br />\n<br />\n<em>Result Type</em> is the type of object to make.",
      "DescriptionPlain": "OpUndef\n\nMake an intermediate object with no initialization.\n\nResult Type is the type of object to make.",
      "Category": "Miscellaneous",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 45,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSource",
      "Description": "<a id=\"OpSource\"></a><strong>OpSource</strong><br />\n<br />\nDocument what <a href=\"#Source Language\">source language</a> this module was translated from. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Version</em> is the version of the source language.",
      "DescriptionPlain": "OpSource\n\nDocument what source language this module was translated from. This has no semantic impact and can safely be removed from a module.\n\nVersion is the version of the source language.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 1,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "SourceLanguage",
          "Type": "SourceLanguage"
        },
        {
          "Name": "Version",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpSourceExtension",
      "Description": "<a id=\"OpSourceExtension\"></a><strong>OpSourceExtension</strong><br />\n<br />\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Extension</em> is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
      "DescriptionPlain": "OpSourceExtension\n\nDocument an extension to the source language. This has no semantic impact and can safely be removed from a module.\n\nExtension is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "1 + variable",
      "WordCountFix": 1,
      "OpCode": 2,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Extension",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpName",
      "Description": "<a id=\"OpName\"></a><strong>OpName</strong><br />\n<br />\nName a <em>Result &lt;id&gt;</em>. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Target</em> is the <em>Result &lt;id&gt;</em> to name. It can be the <em>Result &lt;id&gt;</em> of any other instruction; a variable, function, type, intermediate result, etc.<br />\n<br />\n<em>Name</em> is the string to name <em>&lt;id&gt;</em> with.",
      "DescriptionPlain": "OpName\n\nName a Result &lt;id&gt;. This has no semantic impact and can safely be removed from a module.\n\nTarget is the Result &lt;id&gt; to name. It can be the Result &lt;id&gt; of any other instruction; a variable, function, type, intermediate result, etc.\n\nName is the string to name &lt;id&gt; with.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 54,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpMemberName",
      "Description": "<a id=\"OpMemberName\"></a><strong>OpMemberName</strong><br />\n<br />\nName a member of a structure type. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Type</em> is the <em>&lt;id&gt;</em> from an <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> instruction.<br />\n<br />\n<em>Member</em> is the number of the member to name in the structure. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\n<em>Name</em> is the string to name the member with.",
      "DescriptionPlain": "OpMemberName\n\nName a member of a structure type. This has no semantic impact and can safely be removed from a module.\n\nType is the &lt;id&gt; from an OpTypeStruct instruction.\n\nMember is the number of the member to name in the structure. The first member is member 0, the next is member 1, &#8230;\n\nName is the string to name the member with.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 55,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Type",
          "Type": "ID"
        },
        {
          "Name": "Member",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpString",
      "Description": "<a id=\"OpString\"></a><strong>OpString</strong><br />\n<br />\nName a string for use with other debug instructions (see <a href=\"#OpLine\"><strong>OpLine</strong></a>). This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>String</em> is the literal string being assigned a <em>Result &lt;id&gt;</em>. It has no result type and no storage.",
      "DescriptionPlain": "OpString\n\nName a string for use with other debug instructions (see OpLine). This has no semantic impact and can safely be removed from a module.\n\nString is the literal string being assigned a Result &lt;id&gt;. It has no result type and no storage.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 56,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "String",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpLine",
      "Description": "<a id=\"OpLine\"></a><strong>OpLine</strong><br />\n<br />\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.<br />\n<br />\n<em>Target</em> is the <em>Result &lt;id&gt;</em> to locate. It can be the <em>Result &lt;id&gt;</em> of any other instruction; a variable, function, type, intermediate result, etc.<br />\n<br />\n<em>File</em> is the <em>&lt;id&gt;</em> from an <a href=\"#OpString\"><strong>OpString</strong></a> instruction and is the source-level file name.<br />\n<br />\n<em>Line</em> is the source-level line number.<br />\n<br />\n<em>Column</em> is the source-level column number.",
      "DescriptionPlain": "OpLine\n\nAdd source-level location information. This has no semantic impact and can safely be removed from a module.\n\nTarget is the Result &lt;id&gt; to locate. It can be the Result &lt;id&gt; of any other instruction; a variable, function, type, intermediate result, etc.\n\nFile is the &lt;id&gt; from an OpString instruction and is the source-level file name.\n\nLine is the source-level line number.\n\nColumn is the source-level column number.",
      "Category": "Debug",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 57,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "File",
          "Type": "ID"
        },
        {
          "Name": "Line",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Column",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpDecorationGroup",
      "Description": "<a id=\"OpDecorationGroup\"></a><strong>OpDecorationGroup</strong><br />\n<br />\nA collector of decorations from <a href=\"#OpDecorate\"><strong>OpDecorate</strong></a> instructions. All such instructions must precede this instruction. Subsequent <a href=\"#OpGroupDecorate\"><strong>OpGroupDecorate</strong></a> and <a href=\"#OpGroupMemberDecorate\"><strong>OpGroupMemberDecorate</strong></a> instructions can consume the <em>Result &lt;id&gt;</em> to apply multiple decorations to multiple target &lt;id&gt;s. Those are the only instructions allowed to consume the <em>Result &lt;id&gt;</em>.",
      "DescriptionPlain": "OpDecorationGroup\n\nA collector of decorations from OpDecorate instructions. All such instructions must precede this instruction. Subsequent OpGroupDecorate and OpGroupMemberDecorate instructions can consume the Result &lt;id&gt; to apply multiple decorations to multiple target &lt;id&gt;s. Those are the only instructions allowed to consume the Result &lt;id&gt;.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 49,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDecorate",
      "Description": "<a id=\"OpDecorate\"></a><strong>OpDecorate</strong><br />\n<br />\nAdd a decoration to another &lt;id&gt;.<br />\n<br />\n<em>Target</em> is the <em>&lt;id&gt;</em> to decorate.  It can potentially be any <em>&lt;id&gt;</em> that is a forward reference. A set of decorations can be grouped together by having multiple <strong>OpDecorate</strong> instructions target the same <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.",
      "DescriptionPlain": "OpDecorate\n\nAdd a decoration to another &lt;id&gt;.\n\nTarget is the &lt;id&gt; to decorate.  It can potentially be any &lt;id&gt; that is a forward reference. A set of decorations can be grouped together by having multiple OpDecorate instructions target the same OpDecorationGroup instruction.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 50,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Decoration",
          "Type": "Decoration"
        },
        {
          "Name": "ExtraOperands",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpMemberDecorate",
      "Description": "<a id=\"OpMemberDecorate\"></a><strong>OpMemberDecorate</strong><br />\n<br />\nAdd a decoration to a member of a structure type.<br />\n<br />\n<em>Structure type</em> is the <em>&lt;id&gt;</em> of a type from <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a>.<br />\n<br />\n<em>Member</em> is the number of the member to decorate in the structure. The first member is member 0, the next is member 1, &#8230;",
      "DescriptionPlain": "OpMemberDecorate\n\nAdd a decoration to a member of a structure type.\n\nStructure type is the &lt;id&gt; of a type from OpTypeStruct.\n\nMember is the number of the member to decorate in the structure. The first member is member 0, the next is member 1, &#8230;",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 51,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "StructureType",
          "Type": "ID"
        },
        {
          "Name": "Member",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Decoration",
          "Type": "Decoration"
        },
        {
          "Name": "ExtraOperands",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpGroupDecorate",
      "Description": "<a id=\"OpGroupDecorate\"></a><strong>OpGroupDecorate</strong><br />\n<br />\nAdd a group of decorations to another &lt;id&gt;.<br />\n<br />\n<em>Decoration group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Target</em>, &#8230; are the target &lt;id&gt;s to decorate with the groups of decorations.",
      "DescriptionPlain": "OpGroupDecorate\n\nAdd a group of decorations to another &lt;id&gt;.\n\nDecoration group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTarget, &#8230; are the target &lt;id&gt;s to decorate with the groups of decorations.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 52,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "DecorationGroup",
          "Type": "ID"
        },
        {
          "Name": "Targets",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpGroupMemberDecorate",
      "Description": "<a id=\"OpGroupMemberDecorate\"></a><strong>OpGroupMemberDecorate</strong><br />\n<br />\nAdd a decoration to a member of a structure type.<br />\n<br />\n<em>Decoration group</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpDecorationGroup\"><strong>OpDecorationGroup</strong></a> instruction.<br />\n<br />\n<em>Target</em>, &#8230; are the target &lt;id&gt;s to decorate with the groups of decorations.",
      "DescriptionPlain": "OpGroupMemberDecorate\n\nAdd a decoration to a member of a structure type.\n\nDecoration group is the &lt;id&gt; of an OpDecorationGroup instruction.\n\nTarget, &#8230; are the target &lt;id&gt;s to decorate with the groups of decorations.",
      "Category": "Annotation",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 53,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "DecorationGroup",
          "Type": "ID"
        },
        {
          "Name": "Targets",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpExtension",
      "Description": "<a id=\"OpExtension\"></a><strong>OpExtension</strong><br />\n<br />\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.<br />\n<br />\n<em>Name</em> is the extension&#8217;s name string.",
      "DescriptionPlain": "OpExtension\n\nDeclare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.\n\nName is the extension&#8217;s name string.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "1 + variable",
      "WordCountFix": 1,
      "OpCode": 3,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpExtInstImport",
      "Description": "<a id=\"OpExtInstImport\"></a><strong>OpExtInstImport</strong><br />\n<br />\nImport an extended set of instructions. It can be later referenced by the <em>Result &lt;id&gt;</em>.<br />\n<br />\n<em>Name</em> is the extended instruction-set&#8217;s name string.<br />\n<br />\nSee <a href=\"#ExtInst\">Extended Instruction Sets</a> for more information.",
      "DescriptionPlain": "OpExtInstImport\n\nImport an extended set of instructions. It can be later referenced by the Result &lt;id&gt;.\n\nName is the extended instruction-set&#8217;s name string.\n\nSee Extended Instruction Sets for more information.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 4,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Name",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpExtInst",
      "Description": "<a id=\"OpExtInst\"></a><strong>OpExtInst</strong><br />\n<br />\nExecute an instruction in an imported set of extended instructions.<br />\n<br />\n<em>Set</em> is the result of an <a href=\"#OpExtInstImport\"><strong>OpExtInstImport</strong></a> instruction.<br />\n<br />\n<em>Instruction</em> is the enumerant of the instruction to execute within the extended instruction <em>Set</em>.<br />\n<br />\n<em>Operand 1, &#8230;</em> are the operands to the extended instruction.",
      "DescriptionPlain": "OpExtInst\n\nExecute an instruction in an imported set of extended instructions.\n\nSet is the result of an OpExtInstImport instruction.\n\nInstruction is the enumerant of the instruction to execute within the extended instruction Set.\n\nOperand 1, &#8230; are the operands to the extended instruction.",
      "Category": "Extension",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 44,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Set",
          "Type": "ID"
        },
        {
          "Name": "Instruction",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Operands",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpMemoryModel",
      "Description": "<a id=\"OpMemoryModel\"></a><strong>OpMemoryModel</strong><br />\n<br />\nSet addressing model and memory model for the entire module.<br />\n<br />\n<em>Addressing Model</em> selects the module&#8217;s addressing model, see <a href=\"#Addressing Model\"><strong>Addressing Model</strong></a>.<br />\n<br />\n<em>Memory Model</em> selects the module&#8217;s memory model, see <a href=\"#Memory Model\"><strong>Memory Model</strong></a>.",
      "DescriptionPlain": "OpMemoryModel\n\nSet addressing model and memory model for the entire module.\n\nAddressing Model selects the module&#8217;s addressing model, see Addressing Model.\n\nMemory Model selects the module&#8217;s memory model, see Memory Model.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 5,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "AddressingModel",
          "Type": "AddressingModel"
        },
        {
          "Name": "MemoryModel",
          "Type": "MemoryModel"
        }
      ]
    },
    {
      "Name": "OpEntryPoint",
      "Description": "<a id=\"OpEntryPoint\"></a><strong>OpEntryPoint</strong><br />\n<br />\nDeclare an entry point and its execution model.<br />\n<br />\n<em>Execution Model</em> is the execution model for the entry point and its static call tree.  See <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.<br />\n<br />\n<em>Entry Point</em> must the <em>Result &lt;id&gt;</em> of an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.",
      "DescriptionPlain": "OpEntryPoint\n\nDeclare an entry point and its execution model.\n\nExecution Model is the execution model for the entry point and its static call tree.  See Execution Model.\n\nEntry Point must the Result &lt;id&gt; of an OpFunction instruction.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 6,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "ExecutionModel",
          "Type": "ExecutionModel"
        },
        {
          "Name": "EntryPoint",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpExecutionMode",
      "Description": "<a id=\"OpExecutionMode\"></a><strong>OpExecutionMode</strong><br />\n<br />\nDeclare an execution mode for an entry point.<br />\n<br />\n<em>Entry Point</em> must be the <em>Entry Point &lt;id&gt;</em> operand of an <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a> instruction.<br />\n<br />\n<em>Mode</em> is the execution mode. See <a href=\"#Execution Mode\">Execution Mode</a>.",
      "DescriptionPlain": "OpExecutionMode\n\nDeclare an execution mode for an entry point.\n\nEntry Point must be the Entry Point &lt;id&gt; operand of an OpEntryPoint instruction.\n\nMode is the execution mode. See Execution Mode.",
      "Category": "Mode-Setting",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 7,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "EntryPoint",
          "Type": "ID"
        },
        {
          "Name": "Mode",
          "Type": "ExecutionMode"
        },
        {
          "Name": "ExtraOperands",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCompileFlag",
      "Description": "<a id=\"OpCompileFlag\"></a><strong>OpCompileFlag</strong><br />\n<br />\nAdd a compilation <em>Flag</em>.",
      "DescriptionPlain": "OpCompileFlag\n\nAdd a compilation Flag.",
      "Category": "Mode-Setting",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "1 + variable",
      "WordCountFix": 1,
      "OpCode": 218,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Flag",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpTypeVoid",
      "Description": "<a id=\"OpTypeVoid\"></a><strong>OpTypeVoid</strong><br />\n<br />\nDeclare the void type.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new void type.",
      "DescriptionPlain": "OpTypeVoid\n\nDeclare the void type.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new void type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 8,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeBool",
      "Description": "<a id=\"OpTypeBool\"></a><strong>OpTypeBool</strong><br />\n<br />\nDeclare the <a href=\"#Boolean\"><em>Boolean type</em></a>.  Values of this type can only be either <strong>true</strong> or <strong>false</strong>. There is no physical size or bit pattern defined for these values.  If they are stored (in conjuction with <a href=\"#OpVariable\"><strong>OpVariable</strong></a>), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader <a href=\"#Storage Class\"><strong>storage classes</strong></a>: <strong>WorkgroupLocal</strong>, <strong>WorkgroupGlobal</strong>, <strong>PrivateGlobal</strong>, and <strong>Function</strong>.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new Boolean type.",
      "DescriptionPlain": "OpTypeBool\n\nDeclare the Boolean type.  Values of this type can only be either true or false. There is no physical size or bit pattern defined for these values.  If they are stored (in conjuction with OpVariable), they can only be used with logical addressing operations, not physical, and only with non-externally visible shader storage classes: WorkgroupLocal, WorkgroupGlobal, PrivateGlobal, and Function.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new Boolean type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 9,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeInt",
      "Description": "<a id=\"OpTypeInt\"></a><strong>OpTypeInt</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>integer type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. The bit pattern of a signed integer value is two&#8217;s complement.<br />\n<br />\n<em>Signedness</em> specifies whether there are signed semantics to preserve or validate.<br />\n0 indicates unsigned, or no signedness semantics<br />\n1 indicates signed semantics.<br />\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new integer type.",
      "DescriptionPlain": "OpTypeInt\n\nDeclare a new integer type.\n\nWidth specifies how many bits wide the type is. The bit pattern of a signed integer value is two&#8217;s complement.\n\nSignedness specifies whether there are signed semantics to preserve or validate.\n0 indicates unsigned, or no signedness semantics\n1 indicates signed semantics.\nIn all cases, the type of operation of an instruction comes from the instruction&#8217;s opcode, not the signedness of the operands.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new integer type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 10,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Width",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Signedness",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeFloat",
      "Description": "<a id=\"OpTypeFloat\"></a><strong>OpTypeFloat</strong><br />\n<br />\nDeclare a new <a href=\"#Floating\"><em>floating-point type</em></a>.<br />\n<br />\n<em>Width</em> specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new floating-point type.",
      "DescriptionPlain": "OpTypeFloat\n\nDeclare a new floating-point type.\n\nWidth specifies how many bits wide the type is. The bit pattern of a floating-point value is as described by the IEEE 754 standard.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new floating-point type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 11,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Width",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeVector",
      "Description": "<a id=\"OpTypeVector\"></a><strong>OpTypeVector</strong><br />\n<br />\nDeclare a new vector type.<br />\n<br />\n<em>Component type</em> is the type of each component in the resulting type.<br />\n<br />\n<em>Component count</em> is the number of compononents in the resulting type.  It must be at least 2.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new vector type.",
      "DescriptionPlain": "OpTypeVector\n\nDeclare a new vector type.\n\nComponent type is the type of each component in the resulting type.\n\nComponent count is the number of compononents in the resulting type.  It must be at least 2.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new vector type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 12,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ComponentType",
          "Type": "ID"
        },
        {
          "Name": "ComponentCount",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeMatrix",
      "Description": "<a id=\"OpTypeMatrix\"></a><strong>OpTypeMatrix</strong><br />\n<br />\nDeclare a new matrix type.<br />\n<br />\n<em>Column type</em> is the type of each column in the matrix.  It must be vector type.<br />\n<br />\n<em>Column count</em> is the number of columns in the new matrix type. It must be at least 2.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new matrix type.",
      "DescriptionPlain": "OpTypeMatrix\n\nDeclare a new matrix type.\n\nColumn type is the type of each column in the matrix.  It must be vector type.\n\nColumn count is the number of columns in the new matrix type. It must be at least 2.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new matrix type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 13,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ColumnType",
          "Type": "ID"
        },
        {
          "Name": "ColumnCount",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpTypeSampler",
      "Description": "<a id=\"OpTypeSampler\"></a><strong>OpTypeSampler</strong><br />\n<br />\nDeclare a new sampler type. Consumed, for example, by <a href=\"#OpTextureSample\"><strong>OpTextureSample</strong></a>.This type is opaque: values of this type have no defined physical size or bit pattern.<br />\n<br />\n<em>Sampled Type</em> is a scalar type, of the type of the components resulting from sampling or loading through this sampler.<br />\n<br />\n<em>Dim</em> is the texture <a href=\"#Dim\">dimensionality</a>.<br />\n<br />\n<em>Content</em> must be one of the following indicated values:<br />\n0 indicates a texture, no filter (no sampling state)<br />\n1 indicates an image<br />\n2 indicates both a texture and filter (sampling state), see <a href=\"#OpTypeFilter\"><strong>OpTypeFilter</strong></a><br />\n<br />\n<em>Arrayed</em> must be one of the following indicated values:<br />\n0 indicates non-arrayed content<br />\n1 indicates arrayed content<br />\n<br />\n<em>Compare</em> must be one of the following indicated values:<br />\n0 indicates depth comparisons are not done<br />\n1 indicates depth comparison are done<br />\n<br />\n<em>MS</em> is <em>multisampled</em> and must be one of the following indicated values:<br />\n0 indicates single-sampled content<br />\n1 indicates multisampled content<br />\n<br />\n<em>Qualifier</em> is an image access qualifier. See <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new sampler type.",
      "DescriptionPlain": "OpTypeSampler\n\nDeclare a new sampler type. Consumed, for example, by OpTextureSample.This type is opaque: values of this type have no defined physical size or bit pattern.\n\nSampled Type is a scalar type, of the type of the components resulting from sampling or loading through this sampler.\n\nDim is the texture dimensionality.\n\nContent must be one of the following indicated values:\n0 indicates a texture, no filter (no sampling state)\n1 indicates an image\n2 indicates both a texture and filter (sampling state), see OpTypeFilter\n\nArrayed must be one of the following indicated values:\n0 indicates non-arrayed content\n1 indicates arrayed content\n\nCompare must be one of the following indicated values:\n0 indicates depth comparisons are not done\n1 indicates depth comparison are done\n\nMS is multisampled and must be one of the following indicated values:\n0 indicates single-sampled content\n1 indicates multisampled content\n\nQualifier is an image access qualifier. See Access Qualifier.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new sampler type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "8 + variable",
      "WordCountFix": 8,
      "OpCode": 14,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SampledType",
          "Type": "ID"
        },
        {
          "Name": "Dim",
          "Type": "Dim"
        },
        {
          "Name": "Content",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Arrayed",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Compare",
          "Type": "LiteralNumber"
        },
        {
          "Name": "MS",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Qualifier",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpTypeFilter",
      "Description": "<a id=\"OpTypeFilter\"></a><strong>OpTypeFilter</strong><br />\n<br />\nDeclare the filter type. Consumed by <a href=\"#OpSampler\"><strong>OpSampler</strong></a>.This type is opaque: values of this type have no defined physical size or bit pattern.",
      "DescriptionPlain": "OpTypeFilter\n\nDeclare the filter type. Consumed by OpSampler.This type is opaque: values of this type have no defined physical size or bit pattern.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 15,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeArray",
      "Description": "<a id=\"OpTypeArray\"></a><strong>OpTypeArray</strong><br />\n<br />\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.<br />\n<br />\n<em>Element Type</em> is the type of each element in the array.<br />\n<br />\n<em>Length</em> is the number of elements in the array.  It must be at least 1. <em>Length</em> must come from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of an <a href=\"#Integer\"><em>Integer-type</em></a> scalar whose value is at least 1.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new array type.",
      "DescriptionPlain": "OpTypeArray\n\nDeclare a new array type: a dynamically-indexable ordered aggregate of elements all having the same type.\n\nElement Type is the type of each element in the array.\n\nLength is the number of elements in the array.  It must be at least 1. Length must come from a constant instruction of an Integer-type scalar whose value is at least 1.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new array type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 16,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ElementType",
          "Type": "ID"
        },
        {
          "Name": "Length",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeRuntimeArray",
      "Description": "<a id=\"OpTypeRuntimeArray\"></a><strong>OpTypeRuntimeArray</strong><br />\n<br />\nDeclare a new run-time array type.  Its length is not known at compile time.<br />\n<br />\n<em>Element type</em> is the type of each element in the array. See <a href=\"#OpArrayLength\"><strong>OpArrayLength</strong></a> for getting the <em>Length</em> of an array of this type.<br />\n<br />\n<a href=\"#Object\">Objects</a> of this type can only be created with <a href=\"#OpVariable\"><strong>OpVariable</strong></a> using the <strong>Uniform</strong> <a href=\"#Storage Class\"><strong>Storage Class</strong></a>.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new run-time array type.",
      "DescriptionPlain": "OpTypeRuntimeArray\n\nDeclare a new run-time array type.  Its length is not known at compile time.\n\nElement type is the type of each element in the array. See OpArrayLength for getting the Length of an array of this type.\n\nObjects of this type can only be created with OpVariable using the Uniform Storage Class.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new run-time array type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 17,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ElementType",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeStruct",
      "Description": "<a id=\"OpTypeStruct\"></a><strong>OpTypeStruct</strong><br />\n<br />\nDeclare a new structure type: an aggregate of heteregeneous members.<br />\n<br />\n<em>Member N type</em> is the type of member <em>N</em> of the structure. The first member is member 0, the next is member 1, &#8230;<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new structure type.",
      "DescriptionPlain": "OpTypeStruct\n\nDeclare a new structure type: an aggregate of heteregeneous members.\n\nMember N type is the type of member N of the structure. The first member is member 0, the next is member 1, &#8230;\n\nResult &lt;id&gt; is the &lt;id&gt; of the new structure type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 18,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Members",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpTypeOpaque",
      "Description": "<a id=\"OpTypeOpaque\"></a><strong>OpTypeOpaque</strong><br />\n<br />\nDeclare a named structure type with no body specified.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new opaque type.",
      "DescriptionPlain": "OpTypeOpaque\n\nDeclare a named structure type with no body specified.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new opaque type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2 + variable",
      "WordCountFix": 2,
      "OpCode": 19,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "TheNameOfTheOpaqueType",
          "Type": "LiteralString"
        }
      ]
    },
    {
      "Name": "OpTypePointer",
      "Description": "<a id=\"OpTypePointer\"></a><strong>OpTypePointer</strong><br />\n<br />\nDeclare a new pointer type.<br />\n<br />\n<em>Storage Class</em> is the <a href=\"#Storage Class\"><strong>Storage Class</strong></a> of the memory holding the object pointed to.<br />\n<br />\n<em>Type</em> is the type of the object pointed to.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new pointer type.",
      "DescriptionPlain": "OpTypePointer\n\nDeclare a new pointer type.\n\nStorage Class is the Storage Class of the memory holding the object pointed to.\n\nType is the type of the object pointed to.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new pointer type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 20,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        },
        {
          "Name": "Type",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeFunction",
      "Description": "<a id=\"OpTypeFunction\"></a><strong>OpTypeFunction</strong><br />\n<br />\nDeclare a new function type.  <a href=\"#OpFunction\"><strong>OpFunction</strong></a> will use this to declare the return type and parameter types of a function.<br />\n<br />\n<em>Return Type</em> is the type of the return value of functions of this type. If the function has no return value, <em>Return Type</em> should be from <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n<br />\n<em>Parameter N Type</em> is the type <em>&lt;id&gt;</em> of the type of parameter <em>N</em>.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new function type.",
      "DescriptionPlain": "OpTypeFunction\n\nDeclare a new function type.  OpFunction will use this to declare the return type and parameter types of a function.\n\nReturn Type is the type of the return value of functions of this type. If the function has no return value, Return Type should be from OpTypeVoid.\n\nParameter N Type is the type &lt;id&gt; of the type of parameter N.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new function type.",
      "Category": "Type-Declaration",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 21,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "ReturnType",
          "Type": "ID"
        },
        {
          "Name": "Parameters",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpTypeEvent",
      "Description": "<a id=\"OpTypeEvent\"></a><strong>OpTypeEvent</strong><br />\n<br />\nDeclare an OpenCL event object.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new event type.",
      "DescriptionPlain": "OpTypeEvent\n\nDeclare an OpenCL event object.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new event type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 22,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeDeviceEvent",
      "Description": "<a id=\"OpTypeDeviceEvent\"></a><strong>OpTypeDeviceEvent</strong><br />\n<br />\nDeclare an OpenCL device-side event object.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new device-side-event type.",
      "DescriptionPlain": "OpTypeDeviceEvent\n\nDeclare an OpenCL device-side event object.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new device-side-event type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 23,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeReserveId",
      "Description": "<a id=\"OpTypeReserveId\"></a><strong>OpTypeReserveId</strong><br />\n<br />\nDeclare an OpenCL reservation id object.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new reservation type.",
      "DescriptionPlain": "OpTypeReserveId\n\nDeclare an OpenCL reservation id object.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new reservation type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 24,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypeQueue",
      "Description": "<a id=\"OpTypeQueue\"></a><strong>OpTypeQueue</strong><br />\n<br />\nDeclare an OpenCL queue object.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new queue type.",
      "DescriptionPlain": "OpTypeQueue\n\nDeclare an OpenCL queue object.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new queue type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 25,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTypePipe",
      "Description": "<a id=\"OpTypePipe\"></a><strong>OpTypePipe</strong><br />\n<br />\nDeclare an OpenCL pipe object type.<br />\n<br />\n<em>Type</em> is the data type of the pipe.<br />\n<br />\n<em>Qualifier</em> is the pipe access qualifier.<br />\n<br />\n<em>Result &lt;id&gt;</em> is the <em>&lt;id&gt;</em> of the new pipe type.",
      "DescriptionPlain": "OpTypePipe\n\nDeclare an OpenCL pipe object type.\n\nType is the data type of the pipe.\n\nQualifier is the pipe access qualifier.\n\nResult &lt;id&gt; is the &lt;id&gt; of the new pipe type.",
      "Category": "Type-Declaration",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 26,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Type",
          "Type": "ID"
        },
        {
          "Name": "Qualifier",
          "Type": "AccessQualifier"
        }
      ]
    },
    {
      "Name": "OpConstantTrue",
      "Description": "<a id=\"OpConstantTrue\"></a><strong>OpConstantTrue</strong><br />\n<br />\nDeclare a <strong>true</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpConstantTrue\n\nDeclare a true Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 27,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstantFalse",
      "Description": "<a id=\"OpConstantFalse\"></a><strong>OpConstantFalse</strong><br />\n<br />\nDeclare a <strong>false</strong> <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar constant.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.",
      "DescriptionPlain": "OpConstantFalse\n\nDeclare a false Boolean-type scalar constant.\n\nResult Type must be the scalar Boolean type.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 28,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstant",
      "Description": "<a id=\"OpConstant\"></a><strong>OpConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>Integer-type</em></a> or <a href=\"#Floating\"><em>Floating-point-type</em></a> scalar constant.<br />\n<br />\n<em>Value</em> is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>Integer type</em></a> or <a href=\"#Floating\"><em>Floating-point type</em></a>.",
      "DescriptionPlain": "OpConstant\n\nDeclare a new Integer-type or Floating-point-type scalar constant.\n\nValue is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.\n\nResult Type must be a scalar Integer type or Floating-point type.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 29,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpConstantComposite",
      "Description": "<a id=\"OpConstantComposite\"></a><strong>OpConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#Composite\"><em>composite</em></a> constant.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. The <em>Constituents</em> must be the <em>&lt;id&gt;</em> of other constant declarations.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Composite\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the operands.",
      "DescriptionPlain": "OpConstantComposite\n\nDeclare a new composite constant.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the &lt;id&gt; of other constant declarations.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands.",
      "Category": "Constant-Creation",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 30,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpConstantSampler",
      "Description": "<a id=\"OpConstantSampler\"></a><strong>OpConstantSampler</strong><br />\n<br />\nDeclare a new null sampler constant.<br />\n<br />\n<em>Mode</em> is the addressing Mode. See <a href=\"#Sampler Addressing Mode\">Sampler Addressing Mode</a>.<br />\n<br />\n<em>Param</em> is one of:<br />\n0: Nonparametric<br />\n1: Parametric<br />\n<br />\n<em>Filter</em> is the filter mode. See <a href=\"#Sampler Filter Mode\">Sampler Filter Mode</a>.",
      "DescriptionPlain": "OpConstantSampler\n\nDeclare a new null sampler constant.\n\nMode is the addressing Mode. See Sampler Addressing Mode.\n\nParam is one of:\n0: Nonparametric\n1: Parametric\n\nFilter is the filter mode. See Sampler Filter Mode.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 31,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Mode",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Param",
          "Type": "LiteralNumber"
        },
        {
          "Name": "Filter",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpConstantNullPointer",
      "Description": "<a id=\"OpConstantNullPointer\"></a><strong>OpConstantNullPointer</strong><br />\n<br />\nDeclare a new null pointer constant.",
      "DescriptionPlain": "OpConstantNullPointer\n\nDeclare a new null pointer constant.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Addr"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 32,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConstantNullObject",
      "Description": "<a id=\"OpConstantNullObject\"></a><strong>OpConstantNullObject</strong><br />\n<br />\nDeclare a new null object constant. The objerct can be a queue, event or reservation id.",
      "DescriptionPlain": "OpConstantNullObject\n\nDeclare a new null object constant. The objerct can be a queue, event or reservation id.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 33,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstantTrue",
      "Description": "<a id=\"OpSpecConstantTrue\"></a><strong>OpSpecConstantTrue</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>true</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantTrue\n\nDeclare a Boolean-type scalar specialization constant with a default value of true.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 34,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstantFalse",
      "Description": "<a id=\"OpSpecConstantFalse\"></a><strong>OpSpecConstantFalse</strong><br />\n<br />\nDeclare a <a href=\"#Boolean\"><em>Boolean-type</em></a> scalar specialization constant with a default value of <strong>false</strong>.<br />\n<br />\nThis instruction can be specialized to become either an <a href=\"#OpConstantTrue\"><strong>OpConstantTrue</strong></a> or <a href=\"#OpConstantFalse\"><strong>OpConstantFalse</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be the scalar <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantFalse\n\nDeclare a Boolean-type scalar specialization constant with a default value of false.\n\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\n\nResult Type must be the scalar Boolean type.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 35,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSpecConstant",
      "Description": "<a id=\"OpSpecConstant\"></a><strong>OpSpecConstant</strong><br />\n<br />\nDeclare a new <a href=\"#Integer\"><em>Integer-type</em></a> or <a href=\"#Floating\"><em>Floating-point-type</em></a> scalar specialization constant.<br />\n<br />\n<em>Value</em> is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.<br />\n<br />\nThis instruction can be specialized to become an <a href=\"#OpConstant\"><strong>OpConstant</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\"><em>Integer type</em></a> or <a href=\"#Floating\"><em>Floating-point type</em></a>.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstant\n\nDeclare a new Integer-type or Floating-point-type scalar specialization constant.\n\nValue is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.\n\nThis instruction can be specialized to become an OpConstant instruction.\n\nResult Type must be a scalar Integer type or Floating-point type.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 36,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpSpecConstantComposite",
      "Description": "<a id=\"OpSpecConstantComposite\"></a><strong>OpSpecConstantComposite</strong><br />\n<br />\nDeclare a new <a href=\"#Composite\"><em>composite</em></a> specialization constant.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. The <em>Constituents</em> must be the <em>&lt;id&gt;</em> of other specialization constant or constant declarations.<br />\n<br />\nThis instruction will be specialized to an <a href=\"#OpConstantComposite\"><strong>OpConstantComposite</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Composite\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the operands.<br />\n<br />\nSee <a href=\"#SpecializationSection\">Specialization</a>.",
      "DescriptionPlain": "OpSpecConstantComposite\n\nDeclare a new composite specialization constant.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the &lt;id&gt; of other specialization constant or constant declarations.\n\nThis instruction will be specialized to an OpConstantComposite instruction.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands.\n\nSee Specialization.",
      "Category": "Constant-Creation",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 37,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpVariable",
      "Description": "<a id=\"OpVariable\"></a><strong>OpVariable</strong><br />\n<br />\nAllocate an object in memory, resulting in a pointer to it, which can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>.<br />\n<br />\n<a href=\"#Storage Class\"><em>Storage Class</em></a> is the kind of memory holding the object.<br />\n<br />\n<em>Initializer</em> is optional.  If <em>Initializer</em> is present, it will be the initial value of the variable&#8217;s memory content. <em>Initializer</em> must be an <em>&lt;id&gt;</em> from a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a>. <em>Initializer</em> must have the same type as the type pointed to by <em>Result Type</em>.<br />\n<br />\n<em>Result Type</em> is a type from <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a>, where the type pointed to is the type of object in memory.",
      "DescriptionPlain": "OpVariable\n\nAllocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.\n\nStorage Class is the kind of memory holding the object.\n\nInitializer is optional.  If Initializer is present, it will be the initial value of the variable&#8217;s memory content. Initializer must be an &lt;id&gt; from a constant instruction. Initializer must have the same type as the type pointed to by Result Type.\n\nResult Type is a type from OpTypePointer, where the type pointed to is the type of object in memory.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 38,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        },
        {
          "Name": "Initializer",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpVariableArray",
      "Description": "<a id=\"OpVariableArray\"></a><strong>OpVariableArray</strong><br />\n<br />\nAllocate <em>N</em> objects sequentially in memory, resulting in a pointer to the first such object.<br />\n<br />\n<a href=\"#Storage Class\"><em>Storage Class</em></a> is the kind of memory holding the object.<br />\n<br />\n<em>N</em> is the number of objects to allocate.<br />\n<br />\n<em>Result Type</em> is a type from <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose type pointed to is the type of one of the <em>N</em> objects allocated in memory.<br />\n<br />\n<strong>Note:</strong> This is not the same thing as allocating a single object that is an array.",
      "DescriptionPlain": "OpVariableArray\n\nAllocate N objects sequentially in memory, resulting in a pointer to the first such object.\n\nStorage Class is the kind of memory holding the object.\n\nN is the number of objects to allocate.\n\nResult Type is a type from OpTypePointer whose type pointed to is the type of one of the N objects allocated in memory.\n\nNote: This is not the same thing as allocating a single object that is an array.",
      "Category": "Memory",
      "Capabilities": [
        "Addr"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 39,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "StorageClass",
          "Type": "StorageClass"
        },
        {
          "Name": "N",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLoad",
      "Description": "<a id=\"OpLoad\"></a><strong>OpLoad</strong><br />\n<br />\nLoad through a pointer.<br />\n<br />\n<em>Pointer</em> is the pointer to load through.  It must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose operand is the same as <em>Result Type</em>.<br />\n<br />\n<em>Memory Access</em> must be a <strong>Memory Access</strong> literal.  See <a href=\"#Memory Access\"><strong>Memory Access</strong></a> for more detail.",
      "DescriptionPlain": "OpLoad\n\nLoad through a pointer.\n\nPointer is the pointer to load through.  It must have a type of OpTypePointer whose operand is the same as Result Type.\n\nMemory Access must be a Memory Access literal.  See Memory Access for more detail.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 46,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "MemoryAccess",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpStore",
      "Description": "<a id=\"OpStore\"></a><strong>OpStore</strong><br />\n<br />\nStore through a pointer.<br />\n<br />\n<em>Pointer</em> is the pointer to store through.  It must have a type of <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> whose operand is the same as the type of <em>Object</em>.<br />\n<br />\n<em>Object</em> is the object to store.<br />\n<br />\n<em>Memory Access</em> must be a <strong>Memory Access</strong> literal.  See <a href=\"#Memory Access\"><strong>Memory Access</strong></a> for more detail.",
      "DescriptionPlain": "OpStore\n\nStore through a pointer.\n\nPointer is the pointer to store through.  It must have a type of OpTypePointer whose operand is the same as the type of Object.\n\nObject is the object to store.\n\nMemory Access must be a Memory Access literal.  See Memory Access for more detail.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 47,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "MemoryAccess",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCopyMemory",
      "Description": "<a id=\"OpCopyMemory\"></a><strong>OpCopyMemory</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. Both operands must be non-void pointers of the same type.  Matching storage class is not required. The amount of memory copied is the size of the type pointed to.<br />\n<br />\n<em>Memory Access</em> must be a <strong>Memory Access</strong> literal.  See <a href=\"#Memory Access\"><strong>Memory Access</strong></a> for more detail.",
      "DescriptionPlain": "OpCopyMemory\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers of the same type.  Matching storage class is not required. The amount of memory copied is the size of the type pointed to.\n\nMemory Access must be a Memory Access literal.  See Memory Access for more detail.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 65,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "MemoryAccess",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCopyMemorySized",
      "Description": "<a id=\"OpCopyMemorySized\"></a><strong>OpCopyMemorySized</strong><br />\n<br />\nCopy from the memory pointed to by <em>Source</em> to the memory pointed to by <em>Target</em>. <br />\n<br />\n<em>Size</em> is the number of bytes to copy.<br />\n<br />\n<em>Memory Access</em> must be a <strong>Memory Access</strong> literal.  See <a href=\"#Memory Access\"><strong>Memory Access</strong></a> for more detail.",
      "DescriptionPlain": "OpCopyMemorySized\n\nCopy from the memory pointed to by Source to the memory pointed to by Target. \n\nSize is the number of bytes to copy.\n\nMemory Access must be a Memory Access literal.  See Memory Access for more detail.",
      "Category": "Memory",
      "Capabilities": [
        "Addr"
      ],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 66,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Target",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "Size",
          "Type": "ID"
        },
        {
          "Name": "MemoryAccess",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpAccessChain",
      "Description": "<a id=\"OpAccessChain\"></a><strong>OpAccessChain</strong><br />\n<br />\nCreate a pointer into a <a href=\"#Composite\"><em>composite</em></a> object that can be used with <a href=\"#OpLoad\"><strong>OpLoad</strong></a> and <a href=\"#OpStore\"><strong>OpStore</strong></a>. <br />\n<br />\n<em>Base</em> must be a pointer type, pointing to the base of the object. <br />\n<br />\n<em>Indexes</em> walk the type hierarchy to the desired depth, potentially down to scalar granularity. The type of the pointer created will be to the type reached by walking the type hierarchy down to the last provided index.<br />\n<br />\nThe storage class of the pointer created will be the same as the storage class of the base operand.",
      "DescriptionPlain": "OpAccessChain\n\nCreate a pointer into a composite object that can be used with OpLoad and OpStore. \n\nBase must be a pointer type, pointing to the base of the object. \n\nIndexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The type of the pointer created will be to the type reached by walking the type hierarchy down to the last provided index.\n\nThe storage class of the pointer created will be the same as the storage class of the base operand.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 93,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpInBoundsAccessChain",
      "Description": "<a id=\"OpInBoundsAccessChain\"></a><strong>OpInBoundsAccessChain</strong><br />\n<br />\nHas the same semantics as <a href=\"#OpAccessChain\"><strong>OpAccessChain</strong></a>, with the addition that the resulting pointer is known to point within the base object.",
      "DescriptionPlain": "OpInBoundsAccessChain\n\nHas the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 94,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Base",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpArrayLength",
      "Description": "<a id=\"OpArrayLength\"></a><strong>OpArrayLength</strong><br />\n<br />\nResult is the array length of a run-time array.<br />\n<br />\n<em>Structure</em> must be an object of type <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> that contains a member that is a run-time array.<br />\n<br />\n<em>Array member</em> is a member number of <em>Structure</em> that must have a type from <a href=\"#OpTypeRuntimeArray\"><strong>OpTypeRuntimeArray</strong></a>.",
      "DescriptionPlain": "OpArrayLength\n\nResult is the array length of a run-time array.\n\nStructure must be an object of type OpTypeStruct that contains a member that is a run-time array.\n\nArray member is a member number of Structure that must have a type from OpTypeRuntimeArray.",
      "Category": "Memory",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 121,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Structure",
          "Type": "ID"
        },
        {
          "Name": "ArrayMember",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpImagePointer",
      "Description": "<a id=\"OpImagePointer\"></a><strong>OpImagePointer</strong><br />\n<br />\nForm a pointer to a texel of an image.  Use of such a pointer is limited to atomic operations.<br />\n<br />\n<em>Image</em> is a pointer to a variable of type of <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> and <em>Sample</em> specify which texel and sample within the image to form an address of.<br />\n<br />\nTBD.  This requires an <strong>Image</strong> <a href=\"#Storage Class\">storage class</a> to be added.",
      "DescriptionPlain": "OpImagePointer\n\nForm a pointer to a texel of an image.  Use of such a pointer is limited to atomic operations.\n\nImage is a pointer to a variable of type of OpTypeSampler.\n\nCoordinate and Sample specify which texel and sample within the image to form an address of.\n\nTBD.  This requires an Image storage class to be added.",
      "Category": "Memory",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 190,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Image",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Sample",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGenericPtrMemSemantics",
      "Description": "<a id=\"OpGenericPtrMemSemantics\"></a><strong>OpGenericPtrMemSemantics</strong><br />\n<br />\nReturns a valid <a href=\"#Memory Semantics\"><strong>Memory Semantics</strong></a> value for <em>ptr</em>. <em>ptr</em> must point to <a href=\"#Storage Class\"><strong>Generic</strong></a>. <br />\n<br />\n<em>Result Type</em> must be a 32-bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> value.",
      "DescriptionPlain": "OpGenericPtrMemSemantics\n\nReturns a valid Memory Semantics value for ptr. ptr must point to Generic. \n\nResult Type must be a 32-bits wide OpTypeInt value.",
      "Category": "Memory",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 233,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Ptr",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFunction",
      "Description": "<a id=\"OpFunction\"></a><strong>OpFunction</strong><br />\n<br />\nDefine a function body.  This instruction must be immediately followed by one <a href=\"#OpFunctionParameter\"><strong>OpFunctionParameter</strong></a> instruction per each formal parameter of this function. This function&#8217;s body will terminate with the next <a href=\"#OpFunctionEnd\"><strong>OpFunctionEnd</strong></a> instruction.<br />\n<br />\n<em>Function Type</em> is the result of an <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a>, which declares the types of the return value and parameters of the function.<br />\n<br />\n<em>Result Type</em> must be the same as the <em>Return Type</em> declared in <em>Function Type</em>.",
      "DescriptionPlain": "OpFunction\n\nDefine a function body.  This instruction must be immediately followed by one OpFunctionParameter instruction per each formal parameter of this function. This function&#8217;s body will terminate with the next OpFunctionEnd instruction.\n\nFunction Type is the result of an OpTypeFunction, which declares the types of the return value and parameters of the function.\n\nResult Type must be the same as the Return Type declared in Function Type.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 40,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FunctionControlMask",
          "Type": "FunctionControlMask"
        },
        {
          "Name": "FunctionType",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFunctionParameter",
      "Description": "<a id=\"OpFunctionParameter\"></a><strong>OpFunctionParameter</strong><br />\n<br />\nDeclare the <em>&lt;id&gt;</em> for a formal parameter belonging to the current function.<br />\n<br />\nThis instruction must immediately follow an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> or <strong>OpFunctionParameter</strong> instruction. The order of contiguous <strong>OpFunctionParameter</strong> instructions is the same order arguments will be listed in an <a href=\"#OpFunctionCall\"><strong>OpFunctionCall</strong></a> instruction to this function. It is also the same order in which <em>Parameter Type</em> operands are listed in the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> of the <em>Function Type</em> operand for this function&#8217;s <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> for all the <strong>OpFunctionParameter</strong> instructions for a function must be the same as, in order, the <em>Parameter Type</em> operands listed in the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> of the <em>Function Type</em> operand for this function&#8217;s <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.",
      "DescriptionPlain": "OpFunctionParameter\n\nDeclare the &lt;id&gt; for a formal parameter belonging to the current function.\n\nThis instruction must immediately follow an OpFunction or OpFunctionParameter instruction. The order of contiguous OpFunctionParameter instructions is the same order arguments will be listed in an OpFunctionCall instruction to this function. It is also the same order in which Parameter Type operands are listed in the OpTypeFunction of the Function Type operand for this function&#8217;s OpFunction instruction.\n\nResult Type for all the OpFunctionParameter instructions for a function must be the same as, in order, the Parameter Type operands listed in the OpTypeFunction of the Function Type operand for this function&#8217;s OpFunction instruction.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 41,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFunctionEnd",
      "Description": "<a id=\"OpFunctionEnd\"></a><strong>OpFunctionEnd</strong><br />\n<br />\nLast instruction of a function definition.",
      "DescriptionPlain": "OpFunctionEnd\n\nLast instruction of a function definition.",
      "Category": "Function",
      "Capabilities": [],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpFunctionCall",
      "Description": "<a id=\"OpFunctionCall\"></a><strong>OpFunctionCall</strong><br />\n<br />\nCall a function.<br />\n<br />\n<em>Function</em> is the <em>&lt;id&gt;</em> of an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> instruction.  This could be a forward reference.<br />\n<br />\n<em>Argument N</em> is the <em>&lt;id&gt;</em> of the object to copy to parameter <em>N</em> of <em>Function</em>.<br />\n<br />\n<em>Result Type</em> is the type of the return value of the function. <br />\n<br />\n<strong>Note:</strong> A forward call is possible because there is no missing type information: <em>Result Type</em> must match the <em>Return Type</em> of the function, and the calling argument types must match the formal parameter types.",
      "DescriptionPlain": "OpFunctionCall\n\nCall a function.\n\nFunction is the &lt;id&gt; of an OpFunction instruction.  This could be a forward reference.\n\nArgument N is the &lt;id&gt; of the object to copy to parameter N of Function.\n\nResult Type is the type of the return value of the function. \n\nNote: A forward call is possible because there is no missing type information: Result Type must match the Return Type of the function, and the calling argument types must match the formal parameter types.",
      "Category": "Function",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 43,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Function",
          "Type": "ID"
        },
        {
          "Name": "Arguments",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpSampler",
      "Description": "<a id=\"OpSampler\"></a><strong>OpSampler</strong><br />\n<br />\nCreate a sampler containing both a filter and texture.<br />\n<br />\n<em>Sampler</em> must be an object whose type is from an <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. Its type must have its <em>Content</em> operand set to 0, indicating a texture with no filter.<br />\n<br />\n<em>Filter</em> must be an object whose type is <a href=\"#OpTypeFilter\"><strong>OpTypeFilter</strong></a>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a> whose <em>Sampled Type</em>, <em>Dimensionality</em>, <em>Arrayed</em>, <em>Comparison</em>, and <em>Multisampled</em> operands all equal those of this instruction&#8217;s <em>Sampler</em> operand. Further, the <em>Result Type</em> must have its <em>Content</em> operand set to 2, indicating both a texture and filter are present.",
      "DescriptionPlain": "OpSampler\n\nCreate a sampler containing both a filter and texture.\n\nSampler must be an object whose type is from an OpTypeSampler. Its type must have its Content operand set to 0, indicating a texture with no filter.\n\nFilter must be an object whose type is OpTypeFilter.\n\nResult Type must be an OpTypeSampler whose Sampled Type, Dimensionality, Arrayed, Comparison, and Multisampled operands all equal those of this instruction&#8217;s Sampler operand. Further, the Result Type must have its Content operand set to 2, indicating both a texture and filter are present.",
      "Category": "Texture",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 67,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Filter",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSample",
      "Description": "<a id=\"OpTextureSample\"></a><strong>OpTextureSample</strong><br />\n<br />\nSample a texture with an implicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>] [, <em>D<sub>ref</sub></em>]) as needed by the definiton of <em>Sampler</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Bias</em> is an optional operand.  If present, it is used as a bias to the implicit level of detail.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureSample\n\nSample a texture with an implicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer] [, Dref]) as needed by the definiton of Sampler. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nBias is an optional operand.  If present, it is used as a bias to the implicit level of detail.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 68,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Bias",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpTextureSampleDref",
      "Description": "<a id=\"OpTextureSampleDref\"></a><strong>OpTextureSampleDref</strong><br />\n<br />\nSample a cube-map-array texture with depth comparison using an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be scalar of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must be for a <a href=\"#Dim\"><strong>Cube</strong></a>-arrayed depth-comparison type.<br />\n<br />\n<em>Coordinate</em> is a vector of size 4 containing (<em>u</em>, <em>v</em>, <em>w</em>, <em>array layer</em>).<br />\n<br />\n<em>D<sub>ref</sub></em> is the depth-comparison reference value.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureSampleDref\n\nSample a cube-map-array texture with depth comparison using an implicit level of detail.\n\nResult Type must be scalar of the same type as Sampled Type of Sampler&#8217;s type.\n\nSampler must be an object of a type made by OpTypeSampler. It must be for a Cube-arrayed depth-comparison type.\n\nCoordinate is a vector of size 4 containing (u, v, w, array layer).\n\nDref is the depth-comparison reference value.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 69,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dref",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleLod",
      "Description": "<a id=\"OpTextureSampleLod\"></a><strong>OpTextureSampleLod</strong><br />\n<br />\nSample a texture using an explicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>] [, <em>D<sub>ref</sub></em>]) as needed by the definiton of <em>Sampler</em>. It may be a vector larger than needed, but all unused components will appear after all used components.<br />\n<br />\n<em>Level of Detail</em> explicitly controls the level of detail used when sampling.",
      "DescriptionPlain": "OpTextureSampleLod\n\nSample a texture using an explicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer] [, Dref]) as needed by the definiton of Sampler. It may be a vector larger than needed, but all unused components will appear after all used components.\n\nLevel of Detail explicitly controls the level of detail used when sampling.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 70,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProj",
      "Description": "<a id=\"OpTextureSampleProj\"></a><strong>OpTextureSampleProj</strong><br />\n<br />\nSample a texture with a projective coordinate using an implicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Bias</em> is an optional operand.  If present, it is used as a bias to the implicit level of detail.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureSampleProj\n\nSample a texture with a projective coordinate using an implicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\nBias is an optional operand.  If present, it is used as a bias to the implicit level of detail.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 71,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Bias",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpTextureSampleGrad",
      "Description": "<a id=\"OpTextureSampleGrad\"></a><strong>OpTextureSampleGrad</strong><br />\n<br />\nSample a texture with an explicit gradient.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>dx</em> and <em>dy</em> are explicit derivatives in the <em>x</em> and <em>y</em> direction to use in computing level of detail. Each is a scalar or vector containing (<em>du/dx</em>[, <em>dv/dx</em>] [, <em>dw/dx</em>]) and (<em>du/dy</em>[, <em>dv/dy</em>] [, <em>dw/dy</em>]). The number of components of each must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleGrad\n\nSample a texture with an explicit gradient.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\ndx and dy are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 72,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dx",
          "Type": "ID"
        },
        {
          "Name": "Dy",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleOffset",
      "Description": "<a id=\"OpTextureSampleOffset\"></a><strong>OpTextureSampleOffset</strong><br />\n<br />\nSample a texture with an offset from a coordinate using an implicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.<br />\n<br />\n<em>Bias</em> is an optional operand.  If present, it is used as a bias to the implicit level of detail.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureSampleOffset\n\nSample a texture with an offset from a coordinate using an implicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.\n\nBias is an optional operand.  If present, it is used as a bias to the implicit level of detail.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 73,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        },
        {
          "Name": "Bias",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProjLod",
      "Description": "<a id=\"OpTextureSampleProjLod\"></a><strong>OpTextureSampleProjLod</strong><br />\n<br />\nSample a texture with a projective coordinate using an explicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Level of Detail</em> explicitly controls the level of detail used when sampling.",
      "DescriptionPlain": "OpTextureSampleProjLod\n\nSample a texture with a projective coordinate using an explicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\nLevel of Detail explicitly controls the level of detail used when sampling.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 74,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProjGrad",
      "Description": "<a id=\"OpTextureSampleProjGrad\"></a><strong>OpTextureSampleProjGrad</strong><br />\n<br />\nSample a texture with a projective coordinate using an explicit gradient.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>dx</em> and <em>dy</em> are explicit derivatives in the <em>x</em> and <em>y</em> direction to use in computing level of detail. Each is a scalar or vector containing (<em>du/dx</em>[, <em>dv/dx</em>] [, <em>dw/dx</em>]) and (<em>du/dy</em>[, <em>dv/dy</em>] [, <em>dw/dy</em>]). The number of components of each must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleProjGrad\n\nSample a texture with a projective coordinate using an explicit gradient.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\ndx and dy are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 75,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dx",
          "Type": "ID"
        },
        {
          "Name": "Dy",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleLodOffset",
      "Description": "<a id=\"OpTextureSampleLodOffset\"></a><strong>OpTextureSampleLodOffset</strong><br />\n<br />\nSample a texture with explicit level of detail using an offset from a coordinate.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Level of Detail</em> explicitly controls the level of detail used when sampling.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleLodOffset\n\nSample a texture with explicit level of detail using an offset from a coordinate.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nLevel of Detail explicitly controls the level of detail used when sampling.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 76,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProjOffset",
      "Description": "<a id=\"OpTextureSampleProjOffset\"></a><strong>OpTextureSampleProjOffset</strong><br />\n<br />\nSample a texture with an offset from a projective coordinate using an implicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.<br />\n<br />\n<em>Bias</em> is an optional operand.  If present, it is used as a bias to the implicit level of detail.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureSampleProjOffset\n\nSample a texture with an offset from a projective coordinate using an implicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.\n\nBias is an optional operand.  If present, it is used as a bias to the implicit level of detail.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6 + variable",
      "WordCountFix": 6,
      "OpCode": 77,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        },
        {
          "Name": "Bias",
          "Type": "ID?"
        }
      ]
    },
    {
      "Name": "OpTextureSampleGradOffset",
      "Description": "<a id=\"OpTextureSampleGradOffset\"></a><strong>OpTextureSampleGradOffset</strong><br />\n<br />\nSample a texture with an offset coordinate and an explicit gradient.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>dx</em> and <em>dy</em> are explicit derivatives in the <em>x</em> and <em>y</em> direction to use in computing level of detail. Each is a scalar or vector containing (<em>du/dx</em>[, <em>dv/dx</em>] [, <em>dw/dx</em>]) and (<em>du/dy</em>[, <em>dv/dy</em>] [, <em>dw/dy</em>]). The number of components of each must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleGradOffset\n\nSample a texture with an offset coordinate and an explicit gradient.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\ndx and dy are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 78,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dx",
          "Type": "ID"
        },
        {
          "Name": "Dy",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProjLodOffset",
      "Description": "<a id=\"OpTextureSampleProjLodOffset\"></a><strong>OpTextureSampleProjLodOffset</strong><br />\n<br />\nSample a texture with an offset from a projective coordinate and an explicit level of detail.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Level of Detail</em> explicitly controls the level of detail used when sampling.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleProjLodOffset\n\nSample a texture with an offset from a projective coordinate and an explicit level of detail.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\nLevel of Detail explicitly controls the level of detail used when sampling.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 79,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureSampleProjGradOffset",
      "Description": "<a id=\"OpTextureSampleProjGradOffset\"></a><strong>OpTextureSampleProjGradOffset</strong><br />\n<br />\nSample a texture with an offset from a projective coordinate and an explicit gradient.<br />\n<br />\n<em>Result Type&#8217;s</em> component type must be the same as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. <em>Result Type</em> must be scalar if the <em>Sampler&#8217;s</em> type sets depth-comparison, and must be a vector of four components if the <em>Sampler&#8217;s</em> type does not set depth-comparison.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.<br />\n<br />\n<em>Coordinate</em> is a floating-point vector of four components containing (<em>u</em> [, <em>v</em>] [, <em>D<sub>ref</sub></em>], <em>q</em>) or (<em>u</em> [, <em>v</em>] [, <em>w</em>], <em>q</em>), as needed by the definiton of <em>Sampler</em>, with the <em>q</em> component consumed for the projective division. That is, the actual sample coordinate will be (<em>u/q</em> [, <em>v/q</em>] [,<em>D<sub>ref</sub>/q</em>]) or (<em>u/q</em> [, <em>v/q</em>] [, <em>w/q</em>]), as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>dx</em> and <em>dy</em> are explicit derivatives in the <em>x</em> and <em>y</em> direction to use in computing level of detail. Each is a scalar or vector containing (<em>du/dx</em>[, <em>dv/dx</em>] [, <em>dw/dx</em>]) and (<em>du/dy</em>[, <em>dv/dy</em>] [, <em>dw/dy</em>]). The number of components of each must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureSampleProjGradOffset\n\nSample a texture with an offset from a projective coordinate and an explicit gradient.\n\nResult Type&#8217;s component type must be the same as Sampled Type of Sampler&#8217;s type. Result Type must be scalar if the Sampler&#8217;s type sets depth-comparison, and must be a vector of four components if the Sampler&#8217;s type does not set depth-comparison.\n\nSampler must be an object of a type made by OpTypeSampler.\n\nCoordinate is a floating-point vector of four components containing (u [, v] [, Dref], q) or (u [, v] [, w], q), as needed by the definiton of Sampler, with the q component consumed for the projective division. That is, the actual sample coordinate will be (u/q [, v/q] [,Dref/q]) or (u/q [, v/q] [, w/q]), as needed by the definiton of Sampler.\n\ndx and dy are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 80,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Dx",
          "Type": "ID"
        },
        {
          "Name": "Dy",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureFetchTexel",
      "Description": "<a id=\"OpTextureFetchTexel\"></a><strong>OpTextureFetchTexel</strong><br />\n<br />\nFetch a single texel from a texture.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>. It cannot have depth-comparison type (the type&#8217;s <em>Compare</em> operand must be 0).<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Level of Detail</em> explicitly controls the level of detail used when sampling.",
      "DescriptionPlain": "OpTextureFetchTexel\n\nFetch a single texel from a texture.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of 1D, 2D, 3D, or Rect. It cannot have depth-comparison type (the type&#8217;s Compare operand must be 0).\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nLevel of Detail explicitly controls the level of detail used when sampling.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 81,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureFetchTexelOffset",
      "Description": "<a id=\"OpTextureFetchTexelOffset\"></a><strong>OpTextureFetchTexelOffset</strong><br />\n<br />\nFetch a single offset texel from a texture.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Rect</strong>. It cannot have depth-comparison type (the type&#8217;s <em>Compare</em> operand must be 0).<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>, <em>w</em>) before texel lookup. It must be an <em>&lt;id&gt;</em> of an integer-based <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in <em>Offset</em> must equal the number of components in <em>Coordinate</em>, minus the <em>array layer</em> component, if present.",
      "DescriptionPlain": "OpTextureFetchTexelOffset\n\nFetch a single offset texel from a texture.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of 1D, 2D, 3D, or Rect. It cannot have depth-comparison type (the type&#8217;s Compare operand must be 0).\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nOffset is added to (u, v, w) before texel lookup. It must be an &lt;id&gt; of an integer-based constant instruction of scalar or vector type. It is a compile-time error if these fall outside a target-dependent allowed range. The number of components in Offset must equal the number of components in Coordinate, minus the array layer component, if present.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 82,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureFetchSample",
      "Description": "<a id=\"OpTextureFetchSample\"></a><strong>OpTextureFetchSample</strong><br />\n<br />\nFetch a single sample from a multi-sample texture.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must be a multi-sample texture.<br />\n<br />\n<em>Coordinate</em> is an integer scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Sample</em> is the sample number of the sample to return",
      "DescriptionPlain": "OpTextureFetchSample\n\nFetch a single sample from a multi-sample texture.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type.\n\nSampler must be an object of a type made by OpTypeSampler. It must be a multi-sample texture.\n\nCoordinate is an integer scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nSample is the sample number of the sample to return",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 83,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Sample",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureFetchBuffer",
      "Description": "<a id=\"OpTextureFetchBuffer\"></a><strong>OpTextureFetchBuffer</strong><br />\n<br />\nFetch an element out of a buffer texture.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>Buffer</strong>.<br />\n<br />\n<em>Element</em> is a scalar integer index into the buffer.",
      "DescriptionPlain": "OpTextureFetchBuffer\n\nFetch an element out of a buffer texture.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of Buffer.\n\nElement is a scalar integer index into the buffer.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 84,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Element",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureGather",
      "Description": "<a id=\"OpTextureGather\"></a><strong>OpTextureGather</strong><br />\n<br />\nGathers the requested component from four sampled texels.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. The result has one component per gathered texel.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>2D</strong>, <strong>Cube</strong>, or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>] [, <em>D<sub>ref</sub></em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Component</em> is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.",
      "DescriptionPlain": "OpTextureGather\n\nGathers the requested component from four sampled texels.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type. The result has one component per gathered texel.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of 2D, Cube, or Rect.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer] [, Dref]) as needed by the definiton of Sampler.\n\nComponent is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 85,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureGatherOffset",
      "Description": "<a id=\"OpTextureGatherOffset\"></a><strong>OpTextureGatherOffset</strong><br />\n<br />\nGathers the requested component from four offset sampled texels.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. The result has one component per gathered texel.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>2D</strong> or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>] [, <em>D<sub>ref</sub></em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Component</em> is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Offset</em> is added to (<em>u</em>, <em>v</em>) before texel lookup. It is a compile-time error if these fall outside a target-dependent allowed range.",
      "DescriptionPlain": "OpTextureGatherOffset\n\nGathers the requested component from four offset sampled texels.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type. The result has one component per gathered texel.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of 2D or Rect.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer] [, Dref]) as needed by the definiton of Sampler.\n\nComponent is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.\n\nOffset is added to (u, v) before texel lookup. It is a compile-time error if these fall outside a target-dependent allowed range.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 86,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Offset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureGatherOffsets",
      "Description": "<a id=\"OpTextureGatherOffsets\"></a><strong>OpTextureGatherOffsets</strong><br />\n<br />\nGathers the requested component from four offset sampled texels.<br />\n<br />\n<em>Result Type</em> must be a vector of four components of the same type as <em>Sampled Type</em> of <em>Sampler&#8217;s</em> type. The result has one component per gathered texel.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. It must have a <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>2D</strong> or <strong>Rect</strong>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>] [, <em>D<sub>ref</sub></em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\n<em>Component</em> is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.<br />\n<br />\n<em>Offsets</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> making an array of size four of vectors of two integer components. Each gathered texel is identified by adding one of these array elements to the (<em>u</em>, <em>v</em>) sampled location. It is a compile-time error if this falls outside a target-dependent allowed range.",
      "DescriptionPlain": "OpTextureGatherOffsets\n\nGathers the requested component from four offset sampled texels.\n\nResult Type must be a vector of four components of the same type as Sampled Type of Sampler&#8217;s type. The result has one component per gathered texel.\n\nSampler must be an object of a type made by OpTypeSampler. It must have a Dimensionality of 2D or Rect.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer] [, Dref]) as needed by the definiton of Sampler.\n\nComponent is component number that will be gathered from all four texels.  It must be 0, 1, 2 or 3.\n\nOffsets must be an &lt;id&gt; of a constant instruction making an array of size four of vectors of two integer components. Each gathered texel is identified by adding one of these array elements to the (u, v) sampled location. It is a compile-time error if this falls outside a target-dependent allowed range.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 87,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Offsets",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureQuerySizeLod",
      "Description": "<a id=\"OpTextureQuerySizeLod\"></a><strong>OpTextureQuerySizeLod</strong><br />\n<br />\nQuery the dimensions of the texture for <em>Sampler</em> for mipmap level for <em>Level of Detail</em>.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>1D</strong> <a href=\"#Dim\"><strong>Dimensionality</strong></a>,<br />\n2 for <strong>2D</strong>, and <strong>Cube</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\n3 for <strong>3D</strong> <a href=\"#Dim\"><strong>Dimensionality</strong></a>,<br />\nplus 1 more if the sampler type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>depth</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in a texture array, or the number of cubes in a cube-map array.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. <em>Sampler</em> must have a type with <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>. <em>Sampler</em> cannot have a multisampled type. See <a href=\"#OpTextureQuerySize\"><strong>OpTextureQuerySize</strong></a> for querying texture types lacking level of detail.<br />\n<br />\n<em>Level of Detail</em> is used to compute which mipmap level to query, as described in the API specification.",
      "DescriptionPlain": "OpTextureQuerySizeLod\n\nQuery the dimensions of the texture for Sampler for mipmap level for Level of Detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for 1D Dimensionality,\n2 for 2D, and Cube Dimensionalities,\n3 for 3D Dimensionality,\nplus 1 more if the sampler type is arrayed. This vector is filled in with (width [, height] [, depth] [, elements]) where elements is the number of layers in a texture array, or the number of cubes in a cube-map array.\n\nSampler must be an object of a type made by OpTypeSampler. Sampler must have a type with Dimensionality of 1D, 2D, 3D, or Cube. Sampler cannot have a multisampled type. See OpTextureQuerySize for querying texture types lacking level of detail.\n\nLevel of Detail is used to compute which mipmap level to query, as described in the API specification.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 88,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "LevelOfDetail",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureQuerySize",
      "Description": "<a id=\"OpTextureQuerySize\"></a><strong>OpTextureQuerySize</strong><br />\n<br />\nQuery the dimensions of the texture for <em>Sampler</em>, with no level of detail.<br />\n<br />\n<em>Result Type</em> must be an <a href=\"#Integer\">integer type</a> scalar or vector.  The number of components must be<br />\n1 for <strong>Buffer</strong> <a href=\"#Dim\"><strong>Dimensionality</strong></a>,<br />\n2 for <strong>2D</strong> and <strong>Rect</strong> <a href=\"#Dim\"><strong>Dimensionalities</strong></a>,<br />\nplus 1 more if the sampler type is arrayed. This vector is filled in with (<em>width</em> [, <em>height</em>] [, <em>elements</em>]) where <em>elements</em> is the number of layers in a texture array.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. <em>Sampler</em> must have a type with <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>Rect</strong> or <strong>Buffer</strong>, or be multisampled <strong>2D</strong>. <em>Sampler</em> cannot have a texture with levels of detail; there is no implicit level-of-detail consumed by this instruction. See <a href=\"#OpTextureQuerySizeLod\"><strong>OpTextureQuerySizeLod</strong></a> for querying textures having level of detail.",
      "DescriptionPlain": "OpTextureQuerySize\n\nQuery the dimensions of the texture for Sampler, with no level of detail.\n\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for Buffer Dimensionality,\n2 for 2D and Rect Dimensionalities,\nplus 1 more if the sampler type is arrayed. This vector is filled in with (width [, height] [, elements]) where elements is the number of layers in a texture array.\n\nSampler must be an object of a type made by OpTypeSampler. Sampler must have a type with Dimensionality of Rect or Buffer, or be multisampled 2D. Sampler cannot have a texture with levels of detail; there is no implicit level-of-detail consumed by this instruction. See OpTextureQuerySizeLod for querying textures having level of detail.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 89,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureQueryLod",
      "Description": "<a id=\"OpTextureQueryLod\"></a><strong>OpTextureQueryLod</strong><br />\n<br />\nQuery the mipmap level and the level of detail for a hypothetical sampling of <em>Sampler</em> at <em>Coordinate</em> using an implicit level of detail.<br />\n<br />\n<em>Result Type</em> must be a two-component <a href=\"#Floating\">floating-point type</a> vector.<br />\nThe first component of the result will contain the mipmap array layer.<br />\nThe second component of the result will contain the implicit level of detail relative to the base level.<br />\n<br />\nTBD: Does this need the GLSL pseudo code for computing array layer and LoD?<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. <em>Sampler</em> must have a type with <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.<br />\n<br />\n<em>Coordinate</em> is a floating-point scalar or vector containing (<em>u</em>[, <em>v</em>] &#8230; [, <em>array layer</em>]) as needed by the definiton of <em>Sampler</em>.<br />\n<br />\nIf called on an incomplete texture, the results are undefined.<br />\n<br />\nThis instruction is only allowed under the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "DescriptionPlain": "OpTextureQueryLod\n\nQuery the mipmap level and the level of detail for a hypothetical sampling of Sampler at Coordinate using an implicit level of detail.\n\nResult Type must be a two-component floating-point type vector.\nThe first component of the result will contain the mipmap array layer.\nThe second component of the result will contain the implicit level of detail relative to the base level.\n\nTBD: Does this need the GLSL pseudo code for computing array layer and LoD?\n\nSampler must be an object of a type made by OpTypeSampler. Sampler must have a type with Dimensionality of 1D, 2D, 3D, or Cube.\n\nCoordinate is a floating-point scalar or vector containing (u[, v] &#8230; [, array layer]) as needed by the definiton of Sampler.\n\nIf called on an incomplete texture, the results are undefined.\n\nThis instruction is only allowed under the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 90,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        },
        {
          "Name": "Coordinate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureQueryLevels",
      "Description": "<a id=\"OpTextureQueryLevels\"></a><strong>OpTextureQueryLevels</strong><br />\n<br />\nQuery the number of mipmap levels accessible through <em>Sampler</em>.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of mipmap levels, as defined by the API specification.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. <em>Sampler</em> must have a type with <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>1D</strong>, <strong>2D</strong>, <strong>3D</strong>, or <strong>Cube</strong>.<br />\n<br />\nTBD: The value zero will be returned if no texture or an incomplete texture is associated with <em>Sampler</em>.",
      "DescriptionPlain": "OpTextureQueryLevels\n\nQuery the number of mipmap levels accessible through Sampler.\n\nResult Type must be a scalar integer type. The result is the number of mipmap levels, as defined by the API specification.\n\nSampler must be an object of a type made by OpTypeSampler. Sampler must have a type with Dimensionality of 1D, 2D, 3D, or Cube.\n\nTBD: The value zero will be returned if no texture or an incomplete texture is associated with Sampler.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 91,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTextureQuerySamples",
      "Description": "<a id=\"OpTextureQuerySamples\"></a><strong>OpTextureQuerySamples</strong><br />\n<br />\nQuery the number of samples available per texel fetch in a multisample texture.<br />\n<br />\n<em>Result Type</em> must be a scalar <a href=\"#Integer\">integer type</a>. The result is the number of samples.<br />\n<br />\n<em>Sampler</em> must be an object of a type made by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>. <em>Sampler</em> must have a type with <a href=\"#Dim\"><strong>Dimensionality</strong></a> of <strong>2D</strong> and be a multisample texture.",
      "DescriptionPlain": "OpTextureQuerySamples\n\nQuery the number of samples available per texel fetch in a multisample texture.\n\nResult Type must be a scalar integer type. The result is the number of samples.\n\nSampler must be an object of a type made by OpTypeSampler. Sampler must have a type with Dimensionality of 2D and be a multisample texture.",
      "Category": "Texture",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 92,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Sampler",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertFToU",
      "Description": "<a id=\"OpConvertFToU\"></a><strong>OpConvertFToU</strong><br />\n<br />\nConvert (value preserving) <em>Float Value</em> from floating point to unsigned integer, with round toward 0.0.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components. <em>Result Type</em> cannot be a signed integer type.",
      "DescriptionPlain": "OpConvertFToU\n\nConvert (value preserving) Float Value from floating point to unsigned integer, with round toward 0.0.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components. Result Type cannot be a signed integer type.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 100,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertFToS",
      "Description": "<a id=\"OpConvertFToS\"></a><strong>OpConvertFToS</strong><br />\n<br />\nConvert (value preserving) <em>Float Value</em> from floating point to signed integer, with round toward 0.0.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpConvertFToS\n\nConvert (value preserving) Float Value from floating point to signed integer, with round toward 0.0.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 101,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertSToF",
      "Description": "<a id=\"OpConvertSToF\"></a><strong>OpConvertSToF</strong><br />\n<br />\nConvert (value preserving) <em>Signed Value</em> from signed integer to floating point.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpConvertSToF\n\nConvert (value preserving) Signed Value from signed integer to floating point.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 102,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertUToF",
      "Description": "<a id=\"OpConvertUToF\"></a><strong>OpConvertUToF</strong><br />\n<br />\nConvert (value preserving) <em>Unsigned value</em> from unsigned integer to floating point.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpConvertUToF\n\nConvert (value preserving) Unsigned value from unsigned integer to floating point.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 103,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "UnsignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUConvert",
      "Description": "<a id=\"OpUConvert\"></a><strong>OpUConvert</strong><br />\n<br />\nConvert (value preserving) the width of <em>Unsigned value</em>.  This is either a truncate or a zero extend.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components. The widths of the components of the operand and the <em>Result Type</em> must be different. <em>Result Type</em> cannot be a signed integer type.",
      "DescriptionPlain": "OpUConvert\n\nConvert (value preserving) the width of Unsigned value.  This is either a truncate or a zero extend.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components. The widths of the components of the operand and the Result Type must be different. Result Type cannot be a signed integer type.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 104,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "UnsignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSConvert",
      "Description": "<a id=\"OpSConvert\"></a><strong>OpSConvert</strong><br />\n<br />\nConvert (value preserving) the width of <em>Signed Value</em>.  This is either a truncate or a sign extend.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components. The widths of the components of the operand and the <em>Result Type</em> must be different.",
      "DescriptionPlain": "OpSConvert\n\nConvert (value preserving) the width of Signed Value.  This is either a truncate or a sign extend.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components. The widths of the components of the operand and the Result Type must be different.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 105,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SignedValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFConvert",
      "Description": "<a id=\"OpFConvert\"></a><strong>OpFConvert</strong><br />\n<br />\nConvert (value preserving) the width of <em>Float Value</em>.<br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components. The widths of the components of the operand and the <em>Result Type</em> must be different.",
      "DescriptionPlain": "OpFConvert\n\nConvert (value preserving) the width of Float Value.\n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components. The widths of the components of the operand and the Result Type must be different.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 106,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "FloatValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertPtrToU",
      "Description": "<a id=\"OpConvertPtrToU\"></a><strong>OpConvertPtrToU</strong><br />\n<br />\nConvert <em>Pointer</em> to an unsigned integer type. A <em>Result Type</em> width larger than the width of <em>Pointer</em> will zero extend. A <em>Result Type</em> smaller than the width of <em>Pointer</em> will truncate. For same-width source and target, this is the same as <a href=\"#OpBitcast\"><strong>OpBitCast</strong></a>. <br />\n<br />\n <em>Result Type</em> cannot be a signed integer type.",
      "DescriptionPlain": "OpConvertPtrToU\n\nConvert Pointer to an unsigned integer type. A Result Type width larger than the width of Pointer will zero extend. A Result Type smaller than the width of Pointer will truncate. For same-width source and target, this is the same as OpBitCast. \n\n Result Type cannot be a signed integer type.",
      "Category": "Conversion",
      "Capabilities": [
        "Addr"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 107,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpConvertUToPtr",
      "Description": "<a id=\"OpConvertUToPtr\"></a><strong>OpConvertUToPtr</strong><br />\n<br />\nConverts <em>Integer value</em> to a pointer. A <em>Result Type</em> width smaller than the width of <em>Integer value</em> pointer will truncate. A <em>Result Type</em> width larger than the width of <em>Integer value</em> pointer will zero extend. For same-width source and target, this is the same as <a href=\"#OpBitcast\"><strong>OpBitCast</strong></a>.",
      "DescriptionPlain": "OpConvertUToPtr\n\nConverts Integer value to a pointer. A Result Type width smaller than the width of Integer value pointer will truncate. A Result Type width larger than the width of Integer value pointer will zero extend. For same-width source and target, this is the same as OpBitCast.",
      "Category": "Conversion",
      "Capabilities": [
        "Addr"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 108,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "IntegerValue",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpPtrCastToGeneric",
      "Description": "<a id=\"OpPtrCastToGeneric\"></a><strong>OpPtrCastToGeneric</strong><br />\n<br />\nConverts <em>Source pointer</em> to a pointer value pointing to storage class <a href=\"#Storage Class\"><strong>Generic</strong></a>. <em>Source pointer</em> must point to storage class <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a>, <a href=\"#Storage Class\"><strong>WorkgroupGlobal</strong></a> or <a href=\"#Storage Class\"><strong>Private</strong></a>. <em>Result Type</em> must be a pointer type pointing to storage class <a href=\"#Storage Class\"><strong>Generic</strong></a>. <br />\n<br />\n<em>Result Type</em> and <em>Source pointer</em> must point to the same type.",
      "DescriptionPlain": "OpPtrCastToGeneric\n\nConverts Source pointer to a pointer value pointing to storage class Generic. Source pointer must point to storage class WorkgroupLocal, WorkgroupGlobal or Private. Result Type must be a pointer type pointing to storage class Generic. \n\nResult Type and Source pointer must point to the same type.",
      "Category": "Conversion",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 109,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SourcePointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGenericCastToPtr",
      "Description": "<a id=\"OpGenericCastToPtr\"></a><strong>OpGenericCastToPtr</strong><br />\n<br />\nConverts <em>Source pointer</em> to a non-<a href=\"#Storage Class\"><strong>Generic</strong></a> storage-class pointer value. <em>Source pointer</em> must point to <a href=\"#Storage Class\"><strong>Generic</strong></a>.<br />\n<br />\n<em>Result Type</em> must be a pointer type pointing to <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a>, <a href=\"#Storage Class\"><strong>WorkgroupGlobal</strong></a> or <a href=\"#Storage Class\"><strong>Private</strong></a>.<br />\n<br />\n<em>Result Type</em> and <em>Source pointer</em> must point to the same type.",
      "DescriptionPlain": "OpGenericCastToPtr\n\nConverts Source pointer to a non-Generic storage-class pointer value. Source pointer must point to Generic.\n\nResult Type must be a pointer type pointing to WorkgroupLocal, WorkgroupGlobal or Private.\n\nResult Type and Source pointer must point to the same type.",
      "Category": "Conversion",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 110,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SourcePointer",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitcast",
      "Description": "<a id=\"OpBitcast\"></a><strong>OpBitcast</strong><br />\n<br />\nBit-pattern preserving type conversion for <a href=\"#Numerical\"><em>Numerical-type</em></a> or pointer-type vectors and scalars.<br />\n<br />\n<em>Operand</em> is the bit pattern whose type will change.<br />\n<br />\n<em>Result Type</em> must be different than the type of <em>Operand</em>.  Both <em>Result Type</em> and the type of <em>Operand</em> must be <a href=\"#Numerical\"><em>Numerical-types</em></a> or pointer types. The components of <em>Operand</em> and <em>Result Type</em> must be same bit width. <br />\n<br />\n Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpBitcast\n\nBit-pattern preserving type conversion for Numerical-type or pointer-type vectors and scalars.\n\nOperand is the bit pattern whose type will change.\n\nResult Type must be different than the type of Operand.  Both Result Type and the type of Operand must be Numerical-types or pointer types. The components of Operand and Result Type must be same bit width. \n\n Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "Conversion",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 111,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGenericCastToPtrExplicit",
      "Description": "<a id=\"OpGenericCastToPtrExplicit\"></a><strong>OpGenericCastToPtrExplicit</strong><br />\n<br />\nAttempts to explicitly convert <em>Source pointer</em> to <em>storage</em> storage-class pointer value. <em>Source pointer</em> must point to <a href=\"#Storage Class\"><strong>Generic</strong></a>. If the cast cast fails, the instruction returns an <a href=\"#OpConstantNullPointer\"><strong>OpConstantNullPointer</strong></a> in <em>storage</em> <strong>Storage Class</strong>. <br />\n<br />\n<em>Result Type</em> must be a pointer type pointing to <em>storage</em> <strong>Storage Class</strong>. <em>storage</em> can be one of the following literal values: <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a>, <a href=\"#Storage Class\"><strong>WorkgroupGlobal</strong></a> or <a href=\"#Storage Class\"><strong>Private</strong></a>.<br />\n<br />\n<em>Result Type</em> and <em>Source pointer</em> must point to the same type.",
      "DescriptionPlain": "OpGenericCastToPtrExplicit\n\nAttempts to explicitly convert Source pointer to storage storage-class pointer value. Source pointer must point to Generic. If the cast cast fails, the instruction returns an OpConstantNullPointer in storage Storage Class. \n\nResult Type must be a pointer type pointing to storage Storage Class. storage can be one of the following literal values: WorkgroupLocal, WorkgroupGlobal or Private.\n\nResult Type and Source pointer must point to the same type.",
      "Category": "Conversion",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 232,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "SourcePointer",
          "Type": "ID"
        },
        {
          "Name": "Storage",
          "Type": "StorageClass"
        }
      ]
    },
    {
      "Name": "OpVectorExtractDynamic",
      "Description": "<a id=\"OpVectorExtractDynamic\"></a><strong>OpVectorExtractDynamic</strong><br />\n<br />\nRead a single, dynamically selected, component of a vector.<br />\n<br />\n<em>Vector</em> must be a vector type and is the vector from which to read the component.<br />\n<br />\n<em>Index</em> must be a scalar-integer 0-based index of which component to read.<br />\n<br />\nThe value read is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.<br />\n<br />\nThe <em>Result Type</em> must be the same type as the type of <em>Vector</em>.",
      "DescriptionPlain": "OpVectorExtractDynamic\n\nRead a single, dynamically selected, component of a vector.\n\nVector must be a vector type and is the vector from which to read the component.\n\nIndex must be a scalar-integer 0-based index of which component to read.\n\nThe value read is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.\n\nThe Result Type must be the same type as the type of Vector.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 58,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorInsertDynamic",
      "Description": "<a id=\"OpVectorInsertDynamic\"></a><strong>OpVectorInsertDynamic</strong><br />\n<br />\nWrite a single, variably selected, component into a vector. <br />\n<br />\n<em>Vector</em> must be a vector type and is the vector that the non-written components will be taken from.<br />\n<br />\n<em>Index</em> must be a scalar-integer 0-based index of which component to read.<br />\n<br />\nWhat memory is written is undefined if <em>Index&#8217;s</em> value is less than zero or greater than or equal to the number of components in <em>Vector</em>.<br />\n<br />\nThe <em>Result Type</em> must be the same type as the type of <em>Vector</em>.",
      "DescriptionPlain": "OpVectorInsertDynamic\n\nWrite a single, variably selected, component into a vector. \n\nVector must be a vector type and is the vector that the non-written components will be taken from.\n\nIndex must be a scalar-integer 0-based index of which component to read.\n\nWhat memory is written is undefined if Index&#8217;s value is less than zero or greater than or equal to the number of components in Vector.\n\nThe Result Type must be the same type as the type of Vector.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 59,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Component",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorShuffle",
      "Description": "<a id=\"OpVectorShuffle\"></a><strong>OpVectorShuffle</strong><br />\n<br />\nSelect arbitrary components from two vectors to make a new vector.<br />\n<br />\n<em>Vector 1</em> and <em>Vector 2</em> are logically concatenated, forming a single vector with <em>Vector 1&#8217;s</em> components appearing before <em>Vector 2&#8217;s</em>. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to one less than the total number of components. These two vectors must be of the same component type, but do not have to have the same number of components.<br />\n<br />\n<em>Components</em> are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first <em>Component</em> operand,  the second component of the result is selected by the second <em>Component</em> operand, etc.<br />\n<br />\n<em>Result Type</em> must be a vector of the same component type as the <em>Vector</em> operands' component type.  The number of components in <em>Result Type</em> must be the same as the number of <em>Component</em> operands.<br />\n<br />\n<strong>Note:</strong> A vector &#8220;swizzle&#8221; can be done by using the vector for both <em>Vector</em> operands, or using an <a href=\"#OpUndef\"><strong>OpUndef</strong></a> for one of the <em>Vector</em> operands.",
      "DescriptionPlain": "OpVectorShuffle\n\nSelect arbitrary components from two vectors to make a new vector.\n\nVector 1 and Vector 2 are logically concatenated, forming a single vector with Vector 1&#8217;s components appearing before Vector 2&#8217;s. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to one less than the total number of components. These two vectors must be of the same component type, but do not have to have the same number of components.\n\nComponents are these logical numbers (see above), selecting which of the logically numbered components form the result. They can select the components in any order and can repeat components. The first component of the result is selected by the first Component operand,  the second component of the result is selected by the second Component operand, etc.\n\nResult Type must be a vector of the same component type as the Vector operands' component type.  The number of components in Result Type must be the same as the number of Component operands.\n\nNote: A vector &#8220;swizzle&#8221; can be done by using the vector for both Vector operands, or using an OpUndef for one of the Vector operands.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 60,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        },
        {
          "Name": "Components",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCompositeConstruct",
      "Description": "<a id=\"OpCompositeConstruct\"></a><strong>OpCompositeConstruct</strong><br />\n<br />\nConstruct a new <a href=\"#Composite\"><em>composite</em></a> object from a set of constituent objects that will fully form it.<br />\n<br />\n<em>Constituents</em> will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one <em>Constituent</em> for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The <em>Constituents</em> must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two <em>Constituent</em> operands.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#Composite\"><em>composite</em></a> type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the <em>Result Type</em> component type. When constructing a vector, the total number of components in all the operands must equal the number of components in <em>Result Type</em>.",
      "DescriptionPlain": "OpCompositeConstruct\n\nConstruct a new composite object from a set of constituent objects that will fully form it.\n\nConstituents will become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The Constituents must appear in the order needed by the definition of the type of the result. When constructing a vector, there must be at least two Constituent operands.\n\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the Result Type component type. When constructing a vector, the total number of components in all the operands must equal the number of components in Result Type.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 61,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Constituents",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpCompositeExtract",
      "Description": "<a id=\"OpCompositeExtract\"></a><strong>OpCompositeExtract</strong><br />\n<br />\nExtract a part of a <a href=\"#Composite\"><em>composite</em></a> object. <br />\n<br />\n<em>Composite</em> in the composite to extract from.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy, down to component granularity.  All indexes must be in bounds. <br />\n<br />\n<em>Result Type</em> must be the type of object selected by the last provided index.  The instruction result is the extracted object.",
      "DescriptionPlain": "OpCompositeExtract\n\nExtract a part of a composite object. \n\nComposite in the composite to extract from.\n\nIndexes walk the type hierarchy, down to component granularity.  All indexes must be in bounds. \n\nResult Type must be the type of object selected by the last provided index.  The instruction result is the extracted object.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 62,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Composite",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCompositeInsert",
      "Description": "<a id=\"OpCompositeInsert\"></a><strong>OpCompositeInsert</strong><br />\n<br />\nInsert into a <a href=\"#Composite\"><em>composite</em></a> object. <br />\n<br />\n<em>Object</em> is the object to insert.<br />\n<br />\n<em>Composite</em> in the composite to insert into.<br />\n<br />\n<em>Indexes</em> walk the type hierarchy to the desired depth, potentially down to component granularity. All indexes must be in bounds. <br />\n<br />\n<em>Result Type</em> must be the same type as <em>Composite</em>, and the instruction result is a modified version of <em>Composite</em>.",
      "DescriptionPlain": "OpCompositeInsert\n\nInsert into a composite object. \n\nObject is the object to insert.\n\nComposite in the composite to insert into.\n\nIndexes walk the type hierarchy to the desired depth, potentially down to component granularity. All indexes must be in bounds. \n\nResult Type must be the same type as Composite, and the instruction result is a modified version of Composite.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "5 + variable",
      "WordCountFix": 5,
      "OpCode": 63,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Composite",
          "Type": "ID"
        },
        {
          "Name": "Indexes",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpCopyObject",
      "Description": "<a id=\"OpCopyObject\"></a><strong>OpCopyObject</strong><br />\n<br />\nMake a copy of <em>Operand</em>. There are no dereferences involved.<br />\n<br />\n<em>Result Type</em> must match <em>Operand</em> type.  There are no other restrictions on the types.",
      "DescriptionPlain": "OpCopyObject\n\nMake a copy of Operand. There are no dereferences involved.\n\nResult Type must match Operand type.  There are no other restrictions on the types.",
      "Category": "Composite",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 64,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpTranspose",
      "Description": "<a id=\"OpTranspose\"></a><strong>OpTranspose</strong><br />\n<br />\nTranspose a matrix.<br />\n<br />\n<em>Matrix</em> must be an <a href=\"#Intermediate\"><em>intermediate</em></a> <em>&lt;id&gt;</em> whose type comes from an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be an <em>&lt;id&gt;</em> from an <a href=\"#OpTypeMatrix\"><strong>OpTypeMatrix</strong></a> instruction, where the number of columns and the column size is the reverse of those of the type of <em>Matrix</em>.",
      "DescriptionPlain": "OpTranspose\n\nTranspose a matrix.\n\nMatrix must be an intermediate &lt;id&gt; whose type comes from an OpTypeMatrix instruction.\n\nResult Type must be an &lt;id&gt; from an OpTypeMatrix instruction, where the number of columns and the column size is the reverse of those of the type of Matrix.",
      "Category": "Composite",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 112,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSNegate",
      "Description": "<a id=\"OpSNegate\"></a><strong>OpSNegate</strong><br />\n<br />\nSigned-integer subtract of <em>Operand</em> from zero. The operand&#8217;s type and <em>Result Type</em> must both be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpSNegate\n\nSigned-integer subtract of Operand from zero. The operand&#8217;s type and Result Type must both be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 95,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFNegate",
      "Description": "<a id=\"OpFNegate\"></a><strong>OpFNegate</strong><br />\n<br />\nFloating-point subtract of <em>Operand</em> from zero. The operand&#8217;s type and <em>Result Type</em> must both be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "DescriptionPlain": "OpFNegate\n\nFloating-point subtract of Operand from zero. The operand&#8217;s type and Result Type must both be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 96,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpNot",
      "Description": "<a id=\"OpNot\"></a><strong>OpNot</strong><br />\n<br />\nComplement the bits of <em>Operand</em>. The operand type and <em>Result Type</em> must be scalars or vectors of integer types with the same number of components and same component widths.",
      "DescriptionPlain": "OpNot\n\nComplement the bits of Operand. The operand type and Result Type must be scalars or vectors of integer types with the same number of components and same component widths.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 97,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIAdd",
      "Description": "<a id=\"OpIAdd\"></a><strong>OpIAdd</strong><br />\n<br />\nInteger addition of <em>Operand 1</em> and <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpIAdd\n\nInteger addition of Operand 1 and Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 122,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFAdd",
      "Description": "<a id=\"OpFAdd\"></a><strong>OpFAdd</strong><br />\n<br />\nFloating-point addition of <em>Operand 1</em> and <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "DescriptionPlain": "OpFAdd\n\nFloating-point addition of Operand 1 and Operand 2. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 123,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpISub",
      "Description": "<a id=\"OpISub\"></a><strong>OpISub</strong><br />\n<br />\nInteger subtraction of <em>Operand 2</em> from <em>Operand 1</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpISub\n\nInteger subtraction of Operand 2 from Operand 1. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 124,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFSub",
      "Description": "<a id=\"OpFSub\"></a><strong>OpFSub</strong><br />\n<br />\nFloating-point subtraction of <em>Operand 2</em> from <em>Operand 1</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "DescriptionPlain": "OpFSub\n\nFloating-point subtraction of Operand 2 from Operand 1. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 125,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIMul",
      "Description": "<a id=\"OpIMul\"></a><strong>OpIMul</strong><br />\n<br />\nInteger multiplication of <em>Operand 1</em> and <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpIMul\n\nInteger multiplication of Operand 1 and Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 126,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFMul",
      "Description": "<a id=\"OpFMul\"></a><strong>OpFMul</strong><br />\n<br />\nFloating-point multiplication of <em>Operand 1</em> and <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "DescriptionPlain": "OpFMul\n\nFloating-point multiplication of Operand 1 and Operand 2. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 127,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUDiv",
      "Description": "<a id=\"OpUDiv\"></a><strong>OpUDiv</strong><br />\n<br />\nUnsigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. The operands' types and <em>Result Type</em> cannot be signed types. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpUDiv\n\nUnsigned-integer division of Operand 1 divided by Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. The operands' types and Result Type cannot be signed types. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 128,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSDiv",
      "Description": "<a id=\"OpSDiv\"></a><strong>OpSDiv</strong><br />\n<br />\nSigned-integer division of <em>Operand 1</em> divided by <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSDiv\n\nSigned-integer division of Operand 1 divided by Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 129,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFDiv",
      "Description": "<a id=\"OpFDiv\"></a><strong>OpFDiv</strong><br />\n<br />\nFloating-point division of <em>Operand 1</em> divided by <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFDiv\n\nFloating-point division of Operand 1 divided by Operand 2. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 130,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUMod",
      "Description": "<a id=\"OpUMod\"></a><strong>OpUMod</strong><br />\n<br />\nUnsigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. The operands' types and <em>Result Type</em> cannot be signed types. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpUMod\n\nUnsigned modulo operation of Operand 1 modulo Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. The operands' types and Result Type cannot be signed types. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 131,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSRem",
      "Description": "<a id=\"OpSRem\"></a><strong>OpSRem</strong><br />\n<br />\nSigned remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSRem\n\nSigned remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 132,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSMod",
      "Description": "<a id=\"OpSMod\"></a><strong>OpSMod</strong><br />\n<br />\nSigned modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpSMod\n\nSigned modulo operation of Operand 1 modulo Operand 2.  The sign of a non-0 result comes from Operand 2. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 133,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFRem",
      "Description": "<a id=\"OpFRem\"></a><strong>OpFRem</strong><br />\n<br />\nFloating-point remainder operation of <em>Operand 1</em> divided by <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 1</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFRem\n\nFloating-point remainder operation of Operand 1 divided by Operand 2.  The sign of a non-0 result comes from Operand 1. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 134,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFMod",
      "Description": "<a id=\"OpFMod\"></a><strong>OpFMod</strong><br />\n<br />\nFloating-point modulo operation of <em>Operand 1</em> modulo <em>Operand 2</em>.  The sign of a non-0 result comes from <em>Operand 2</em>. The operands' types and <em>Result Type</em> must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if <em>Operand 2</em> is 0.",
      "DescriptionPlain": "OpFMod\n\nFloating-point modulo operation of Operand 1 modulo Operand 2.  The sign of a non-0 result comes from Operand 2. The operands' types and Result Type must  all be scalars or vectors of floating-point types with the same number of components and the same component widths. The resulting value is undefined if Operand 2 is 0.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 135,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorTimesScalar",
      "Description": "<a id=\"OpVectorTimesScalar\"></a><strong>OpVectorTimesScalar</strong><br />\n<br />\nScale a floating-point vector.<br />\n<br />\n<em>Vector</em> must have a floating-point vector type.<br />\n<br />\n<em>Scalar</em> must be a floating-point scalar.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>Vector</em>.",
      "DescriptionPlain": "OpVectorTimesScalar\n\nScale a floating-point vector.\n\nVector must have a floating-point vector type.\n\nScalar must be a floating-point scalar.\n\nResult Type must be the same as the type of Vector.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 136,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Scalar",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesScalar",
      "Description": "<a id=\"OpMatrixTimesScalar\"></a><strong>OpMatrixTimesScalar</strong><br />\n<br />\nScale a floating-point matrix.<br />\n<br />\n<em>Matrix</em> must have a floating-point matrix type.<br />\n<br />\n<em>Scalar</em> must have a floating-point scalar type.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>Matrix</em>.",
      "DescriptionPlain": "OpMatrixTimesScalar\n\nScale a floating-point matrix.\n\nMatrix must have a floating-point matrix type.\n\nScalar must have a floating-point scalar type.\n\nResult Type must be the same as the type of Matrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 137,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        },
        {
          "Name": "Scalar",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpVectorTimesMatrix",
      "Description": "<a id=\"OpVectorTimesMatrix\"></a><strong>OpVectorTimesMatrix</strong><br />\n<br />\nLinear-algebraic <em>Vector</em> X <em>Matrix</em>.<br />\n<br />\n<em>Vector</em> must have a floating-point vector type.<br />\n<br />\n<em>Matrix</em> must have a floating-point matrix type.<br />\n<br />\n<em>Result Type</em> must be a vector whose size is the number of columns in the matrix.",
      "DescriptionPlain": "OpVectorTimesMatrix\n\nLinear-algebraic Vector X Matrix.\n\nVector must have a floating-point vector type.\n\nMatrix must have a floating-point matrix type.\n\nResult Type must be a vector whose size is the number of columns in the matrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 138,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesVector",
      "Description": "<a id=\"OpMatrixTimesVector\"></a><strong>OpMatrixTimesVector</strong><br />\n<br />\nLinear-algebraic <em>Vector</em> X <em>Matrix</em>.<br />\n<br />\n<em>Matrix</em> must have a floating-point matrix type.<br />\n<br />\n<em>Vector</em> must have a floating-point vector type.<br />\n<br />\n<em>Result Type</em> must be a vector whose size is the number of rows in the matrix.",
      "DescriptionPlain": "OpMatrixTimesVector\n\nLinear-algebraic Vector X Matrix.\n\nMatrix must have a floating-point matrix type.\n\nVector must have a floating-point vector type.\n\nResult Type must be a vector whose size is the number of rows in the matrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 139,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Matrix",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpMatrixTimesMatrix",
      "Description": "<a id=\"OpMatrixTimesMatrix\"></a><strong>OpMatrixTimesMatrix</strong><br />\n<br />\nLinear-algebraic multiply of <em>LeftMatrix</em> X <em>RightMatrix</em>.<br />\n<br />\n<em>LeftMatrix</em> and <em>RightMatrix</em> must both have a floating-point matrix type. The number of columns of <em>LeftMatrix</em> must equal the number of rows of <em>RightMatrix</em>.<br />\n<br />\n<em>Result Type</em> must be a matrix whose number of columns is the number of columns in <em>RightMatrix</em> and whose number of rows is the number of rows of <em>LeftMatrix</em>.",
      "DescriptionPlain": "OpMatrixTimesMatrix\n\nLinear-algebraic multiply of LeftMatrix X RightMatrix.\n\nLeftMatrix and RightMatrix must both have a floating-point matrix type. The number of columns of LeftMatrix must equal the number of rows of RightMatrix.\n\nResult Type must be a matrix whose number of columns is the number of columns in RightMatrix and whose number of rows is the number of rows of LeftMatrix.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 140,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "LeftMatrix",
          "Type": "ID"
        },
        {
          "Name": "RightMatrix",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpOuterProduct",
      "Description": "<a id=\"OpOuterProduct\"></a><strong>OpOuterProduct</strong><br />\n<br />\nLinear-algebraic outer product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\nThe operands' types must be floating-point vectors with the same component type and the same number of components.<br />\n<br />\n<em>Result Type</em> must be a matrix type.  Its number of columns must equal the number of components in <em>Vector 2</em>. The vector type of its columns must be the same as the type of <em>Vector 1</em>.",
      "DescriptionPlain": "OpOuterProduct\n\nLinear-algebraic outer product of Vector 1 and Vector 2.\n\nThe operands' types must be floating-point vectors with the same component type and the same number of components.\n\nResult Type must be a matrix type.  Its number of columns must equal the number of components in Vector 2. The vector type of its columns must be the same as the type of Vector 1.",
      "Category": "Arithmetic",
      "Capabilities": [
        "Matrix"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 141,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDot",
      "Description": "<a id=\"OpDot\"></a><strong>OpDot</strong><br />\n<br />\nDot product of <em>Vector 1</em> and <em>Vector 2</em>.<br />\n<br />\nThe operands' types must be floating-point vectors with the same component type and the same number of components.<br />\n<br />\n<em>Result Type</em> must be a scalar of the same type as the operands' component type.",
      "DescriptionPlain": "OpDot\n\nDot product of Vector 1 and Vector 2.\n\nThe operands' types must be floating-point vectors with the same component type and the same number of components.\n\nResult Type must be a scalar of the same type as the operands' component type.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 142,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector1",
          "Type": "ID"
        },
        {
          "Name": "Vector2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftRightLogical",
      "Description": "<a id=\"OpShiftRightLogical\"></a><strong>OpShiftRightLogical</strong><br />\n<br />\nShift the bits in <em>Operand 1</em> right by the number of bits specified in <em>Operand 2</em>.  The most-significant bits will be zero filled. <em>Operand 2</em> is consumed as an unsigned integer. The result is undefined if <em>Operand 2</em> is greater than the bit width of the components of <em>Operand 1</em>. <br />\n<br />\nThe number of components and bit width of <em>Result Type</em> must match those of <em>Operand 1</em> type. All types must be integer types. Works with any mixture of signedness.",
      "DescriptionPlain": "OpShiftRightLogical\n\nShift the bits in Operand 1 right by the number of bits specified in Operand 2.  The most-significant bits will be zero filled. Operand 2 is consumed as an unsigned integer. The result is undefined if Operand 2 is greater than the bit width of the components of Operand 1. \n\nThe number of components and bit width of Result Type must match those of Operand 1 type. All types must be integer types. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 143,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftRightArithmetic",
      "Description": "<a id=\"OpShiftRightArithmetic\"></a><strong>OpShiftRightArithmetic</strong><br />\n<br />\nShift the bits in <em>Operand 1</em> right by the number of bits specified in <em>Operand 2</em>. The most-significant bits will be filled with the sign bit from <em>Operand 1</em>. <em>Operand 2</em> is treated as unsigned.  The result is undefined if <em>Operand 2</em> is greater than the bit width of the components of <em>Operand 1</em>. <br />\n<br />\nThe number of components and bit width of <em>Result Type</em> must match those <em>Operand 1</em> type. All types must be integer types. Works with any mixture of signedness.",
      "DescriptionPlain": "OpShiftRightArithmetic\n\nShift the bits in Operand 1 right by the number of bits specified in Operand 2. The most-significant bits will be filled with the sign bit from Operand 1. Operand 2 is treated as unsigned.  The result is undefined if Operand 2 is greater than the bit width of the components of Operand 1. \n\nThe number of components and bit width of Result Type must match those Operand 1 type. All types must be integer types. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 144,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpShiftLeftLogical",
      "Description": "<a id=\"OpShiftLeftLogical\"></a><strong>OpShiftLeftLogical</strong><br />\n<br />\nShift the bits in <em>Operand 1</em> left by the number of bits specified in <em>Operand 2</em>. The least-significant bits will be zero filled. <em>Operand 2</em> is treated as unsigned.  The result is undefined if <em>Operand 2</em> is greater than the bit width of the components of <em>Operand 1</em>. <br />\n<br />\nThe number of components and bit width of <em>Result Type</em> must match those <em>Operand 1</em> type. All types must be integer types. Works with any mixture of signedness.",
      "DescriptionPlain": "OpShiftLeftLogical\n\nShift the bits in Operand 1 left by the number of bits specified in Operand 2. The least-significant bits will be zero filled. Operand 2 is treated as unsigned.  The result is undefined if Operand 2 is greater than the bit width of the components of Operand 1. \n\nThe number of components and bit width of Result Type must match those Operand 1 type. All types must be integer types. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 145,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseOr",
      "Description": "<a id=\"OpBitwiseOr\"></a><strong>OpBitwiseOr</strong><br />\n<br />\nResult is 1 if either <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if both <em>Operand 1</em> and <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpBitwiseOr\n\nResult is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both Operand 1 and Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 149,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseXor",
      "Description": "<a id=\"OpBitwiseXor\"></a><strong>OpBitwiseXor</strong><br />\n<br />\nResult is 1 if exactly one of <em>Operand 1</em> or <em>Operand 2</em> is 1. Result is 0 if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n Results are computed per component, and within each component, per bit. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpBitwiseXor\n\nResult is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0 if Operand 1 and Operand 2 have the same value.\n\n Results are computed per component, and within each component, per bit. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 150,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBitwiseAnd",
      "Description": "<a id=\"OpBitwiseAnd\"></a><strong>OpBitwiseAnd</strong><br />\n<br />\nResult is 1 if both <em>Operand 1</em> and <em>Operand 2</em> are 1. Result is 0 if either <em>Operand 1</em> or <em>Operand 2</em> are 0.<br />\n<br />\n Results are computed per component, and within each component, per bit. The operands' types and <em>Result Type</em> must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "DescriptionPlain": "OpBitwiseAnd\n\nResult is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either Operand 1 or Operand 2 are 0.\n\n Results are computed per component, and within each component, per bit. The operands' types and Result Type must  all be scalars or vectors of integer        types with the same number of components and the same component widths. Works with any mixture of signedness.",
      "Category": "Arithmetic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 151,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAny",
      "Description": "<a id=\"OpAny\"></a><strong>OpAny</strong><br />\n<br />\nResult is <strong>true</strong> if any component of <em>Vector</em> is <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar.",
      "DescriptionPlain": "OpAny\n\nResult is true if any component of Vector is true, otherwise result is false.\n\nVector must be a vector of Boolean type.\n\n Result Type must be a Boolean type scalar.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 98,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAll",
      "Description": "<a id=\"OpAll\"></a><strong>OpAll</strong><br />\n<br />\nResult is <strong>true</strong> if all components of <em>Vector</em> are <strong>true</strong>, otherwise result is <strong>false</strong>.<br />\n<br />\n<em>Vector</em> must be a vector of <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n <em>Result Type</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar.",
      "DescriptionPlain": "OpAll\n\nResult is true if all components of Vector are true, otherwise result is false.\n\nVector must be a vector of Boolean type.\n\n Result Type must be a Boolean type scalar.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 99,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Vector",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsNan",
      "Description": "<a id=\"OpIsNan\"></a><strong>OpIsNan</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpIsNan\n\nResult is true if x is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 113,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsInf",
      "Description": "<a id=\"OpIsInf\"></a><strong>OpIsInf</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE Inf, otherwise result is <strong>false</strong><br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpIsInf\n\nResult is true if x is an IEEE Inf, otherwise result is false\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 114,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsFinite",
      "Description": "<a id=\"OpIsFinite\"></a><strong>OpIsFinite</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE finite number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpIsFinite\n\nResult is true if x is an IEEE finite number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 115,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsNormal",
      "Description": "<a id=\"OpIsNormal\"></a><strong>OpIsNormal</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> is an IEEE normal number, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpIsNormal\n\nResult is true if x is an IEEE normal number, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 116,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSignBitSet",
      "Description": "<a id=\"OpSignBitSet\"></a><strong>OpSignBitSet</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> has its sign bit set, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and <em>Result Type</em> must     have the same number of components.",
      "DescriptionPlain": "OpSignBitSet\n\nResult is true if x has its sign bit set, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operand. Results are computed per component. The operand&#8217;s type and Result Type must     have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 117,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLessOrGreater",
      "Description": "<a id=\"OpLessOrGreater\"></a><strong>OpLessOrGreater</strong><br />\n<br />\nResult is <strong>true</strong> if <em>x</em> &lt; <em>y</em> or <em>x</em> &gt; <em>y</em>, where IEEE comparisons are used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpLessOrGreater\n\nResult is true if x &lt; y or x &gt; y, where IEEE comparisons are used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 118,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpOrdered",
      "Description": "<a id=\"OpOrdered\"></a><strong>OpOrdered</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>x</em> == <em>x</em> and <em>y</em> == <em>y</em> are <strong>true</strong>, where IEEE comparison is used, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpOrdered\n\nResult is true if both x == x and y == y are true, where IEEE comparison is used, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 119,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUnordered",
      "Description": "<a id=\"OpUnordered\"></a><strong>OpUnordered</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>x</em> or <em>y</em> is an IEEE NaN, otherwise result is <strong>false</strong>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpUnordered\n\nResult is true if either x or y is an IEEE NaN, otherwise result is false.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 120,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "X",
          "Type": "ID"
        },
        {
          "Name": "Y",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalOr",
      "Description": "<a id=\"OpLogicalOr\"></a><strong>OpLogicalOr</strong><br />\n<br />\nResult is <strong>true</strong> if either <em>Operand 1</em> or <em>Operand 2</em> is <strong>true</strong>. Result is <strong>false</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Operand 1</em> and <em>Operand 2</em> must both be scalars or vectors of <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpLogicalOr\n\nResult is true if either Operand 1 or Operand 2 is true. Result is false if both Operand 1 and Operand 2 are false.\n\n Operand 1 and Operand 2 must both be scalars or vectors of Boolean type.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 146,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalXor",
      "Description": "<a id=\"OpLogicalXor\"></a><strong>OpLogicalXor</strong><br />\n<br />\nResult is <strong>true</strong> if exactly one of <em>Operand 1</em> or <em>Operand 2</em> is <strong>true</strong>. Result is <strong>false</strong> if <em>Operand 1</em> and <em>Operand 2</em> have the same value.<br />\n<br />\n <em>Operand 1</em> and <em>Operand 2</em> must both be scalars or vectors of <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpLogicalXor\n\nResult is true if exactly one of Operand 1 or Operand 2 is true. Result is false if Operand 1 and Operand 2 have the same value.\n\n Operand 1 and Operand 2 must both be scalars or vectors of Boolean type.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 147,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpLogicalAnd",
      "Description": "<a id=\"OpLogicalAnd\"></a><strong>OpLogicalAnd</strong><br />\n<br />\nResult is <strong>true</strong> if both <em>Operand 1</em> and <em>Operand 2</em> are <strong>true</strong>. Result is <strong>false</strong> if either <em>Operand 1</em> or <em>Operand 2</em> are <strong>false</strong>.<br />\n<br />\n <em>Operand 1</em> and <em>Operand 2</em> must both be scalars or vectors of <a href=\"#Boolean\"><em>Boolean type</em></a>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands. Results are computed per component. The operands' types and <em>Result Type</em> must all have the same number of components.",
      "DescriptionPlain": "OpLogicalAnd\n\nResult is true if both Operand 1 and Operand 2 are true. Result is false if either Operand 1 or Operand 2 are false.\n\n Operand 1 and Operand 2 must both be scalars or vectors of Boolean type.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands. Results are computed per component. The operands' types and Result Type must all have the same number of components.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 148,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSelect",
      "Description": "<a id=\"OpSelect\"></a><strong>OpSelect</strong><br />\n<br />\nSelect between two objects. Results are computed per component.<br />\n<br />\n<em>Condition</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar or vector.<br />\n<br />\n<em>Object 1</em> is selected as the result if <em>Condition</em> is <strong>true</strong>.<br />\n<br />\n<em>Object 2</em> is selected as the result if <em>Condition</em> is <strong>false</strong>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Object 1</em>, and the type of <em>Object 2</em> must all be the same. <em>Condition</em> must have the same number of components as the operands.",
      "DescriptionPlain": "OpSelect\n\nSelect between two objects. Results are computed per component.\n\nCondition must be a Boolean type scalar or vector.\n\nObject 1 is selected as the result if Condition is true.\n\nObject 2 is selected as the result if Condition is false.\n\nResult Type, the type of Object 1, and the type of Object 2 must all be the same. Condition must have the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 152,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Condition",
          "Type": "ID"
        },
        {
          "Name": "Object1",
          "Type": "ID"
        },
        {
          "Name": "Object2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIEqual",
      "Description": "<a id=\"OpIEqual\"></a><strong>OpIEqual</strong><br />\n<br />\nInteger comparison for equality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpIEqual\n\nInteger comparison for equality.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 153,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdEqual",
      "Description": "<a id=\"OpFOrdEqual\"></a><strong>OpFOrdEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdEqual\n\nFloating-point comparison for being ordered and equal.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 154,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordEqual",
      "Description": "<a id=\"OpFUnordEqual\"></a><strong>OpFUnordEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordEqual\n\nFloating-point comparison for being unordered or equal.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 155,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpINotEqual",
      "Description": "<a id=\"OpINotEqual\"></a><strong>OpINotEqual</strong><br />\n<br />\nInteger comparison for inequality.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpINotEqual\n\nInteger comparison for inequality.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 156,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdNotEqual",
      "Description": "<a id=\"OpFOrdNotEqual\"></a><strong>OpFOrdNotEqual</strong><br />\n<br />\nFloating-point comparison for being ordered and not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdNotEqual\n\nFloating-point comparison for being ordered and not equal.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 157,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordNotEqual",
      "Description": "<a id=\"OpFUnordNotEqual\"></a><strong>OpFUnordNotEqual</strong><br />\n<br />\nFloating-point comparison for being unordered or not equal.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordNotEqual\n\nFloating-point comparison for being unordered or not equal.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 158,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpULessThan",
      "Description": "<a id=\"OpULessThan\"></a><strong>OpULessThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpULessThan\n\nUnsigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 159,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSLessThan",
      "Description": "<a id=\"OpSLessThan\"></a><strong>OpSLessThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpSLessThan\n\nSigned-integer comparison if Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 160,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdLessThan",
      "Description": "<a id=\"OpFOrdLessThan\"></a><strong>OpFOrdLessThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdLessThan\n\nFloating-point comparison if operands are ordered and Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 161,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordLessThan",
      "Description": "<a id=\"OpFUnordLessThan\"></a><strong>OpFUnordLessThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordLessThan\n\nFloating-point comparison if operands are unordered or Operand 1 is less than Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 162,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUGreaterThan",
      "Description": "<a id=\"OpUGreaterThan\"></a><strong>OpUGreaterThan</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpUGreaterThan\n\nUnsigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 163,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSGreaterThan",
      "Description": "<a id=\"OpSGreaterThan\"></a><strong>OpSGreaterThan</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpSGreaterThan\n\nSigned-integer comparison if Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 164,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdGreaterThan",
      "Description": "<a id=\"OpFOrdGreaterThan\"></a><strong>OpFOrdGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdGreaterThan\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 165,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordGreaterThan",
      "Description": "<a id=\"OpFUnordGreaterThan\"></a><strong>OpFUnordGreaterThan</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than  <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordGreaterThan\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than  Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 166,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpULessThanEqual",
      "Description": "<a id=\"OpULessThanEqual\"></a><strong>OpULessThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpULessThanEqual\n\nUnsigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 167,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSLessThanEqual",
      "Description": "<a id=\"OpSLessThanEqual\"></a><strong>OpSLessThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpSLessThanEqual\n\nSigned-integer comparison if Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 168,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdLessThanEqual",
      "Description": "<a id=\"OpFOrdLessThanEqual\"></a><strong>OpFOrdLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdLessThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 169,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordLessThanEqual",
      "Description": "<a id=\"OpFUnordLessThanEqual\"></a><strong>OpFUnordLessThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is less than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordLessThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is less than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 170,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUGreaterThanEqual",
      "Description": "<a id=\"OpUGreaterThanEqual\"></a><strong>OpUGreaterThanEqual</strong><br />\n<br />\nUnsigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpUGreaterThanEqual\n\nUnsigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 171,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSGreaterThanEqual",
      "Description": "<a id=\"OpSGreaterThanEqual\"></a><strong>OpSGreaterThanEqual</strong><br />\n<br />\nSigned-integer comparison if <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpSGreaterThanEqual\n\nSigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 172,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFOrdGreaterThanEqual",
      "Description": "<a id=\"OpFOrdGreaterThanEqual\"></a><strong>OpFOrdGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are ordered and <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFOrdGreaterThanEqual\n\nFloating-point comparison if operands are ordered and Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 173,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFUnordGreaterThanEqual",
      "Description": "<a id=\"OpFUnordGreaterThanEqual\"></a><strong>OpFUnordGreaterThanEqual</strong><br />\n<br />\nFloating-point comparison if operands are unordered or <em>Operand 1</em> is greater than or equal to <em>Operand 2</em>.<br />\n<br />\n <em>Result Type</em> must be a scalar or vector of <a href=\"#Boolean\"><em>Boolean type</em></a>, with the same number of components as the operands.",
      "DescriptionPlain": "OpFUnordGreaterThanEqual\n\nFloating-point comparison if operands are unordered or Operand 1 is greater than or equal to Operand 2.\n\n Result Type must be a scalar or vector of Boolean type, with the same number of components as the operands.",
      "Category": "RelationalAndLogical",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 174,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operand1",
          "Type": "ID"
        },
        {
          "Name": "Operand2",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdx",
      "Description": "<a id=\"OpDPdx\"></a><strong>OpDPdx</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> or <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdx\n\nSame result as either OpDPdxFine or OpDPdxCoarse on P. Selection of which one is based on external factors.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 175,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdy",
      "Description": "<a id=\"OpDPdy\"></a><strong>OpDPdy</strong><br />\n<br />\nSame result as either <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> or <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>. Selection of which one is based on external factors.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdy\n\nSame result as either OpDPdyFine or OpDPdyCoarse on P. Selection of which one is based on external factors.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 176,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidth",
      "Description": "<a id=\"OpFwidth\"></a><strong>OpFwidth</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdx\"><strong>OpDPdx</strong></a> and <a href=\"#OpDPdy\"><strong>OpDPdy</strong></a> on <em>P</em>.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpFwidth\n\nResult is the same as computing the sum of the absolute values of OpDPdx and OpDPdy on P.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 177,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdxFine",
      "Description": "<a id=\"OpDPdxFine\"></a><strong>OpDPdxFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdxFine\n\nResult is the partial derivative of P with respect to the window x coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 178,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdyFine",
      "Description": "<a id=\"OpDPdyFine\"></a><strong>OpDPdyFine</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate.Will use local differencing based on the value of <em>P</em> for the current fragment and its immediate neighbor(s).<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdyFine\n\nResult is the partial derivative of P with respect to the window y coordinate.Will use local differencing based on the value of P for the current fragment and its immediate neighbor(s).\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 179,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidthFine",
      "Description": "<a id=\"OpFwidthFine\"></a><strong>OpFwidthFine</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a> and <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a> on <em>P</em>.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpFwidthFine\n\nResult is the same as computing the sum of the absolute values of OpDPdxFine and OpDPdyFine on P.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 180,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdxCoarse",
      "Description": "<a id=\"OpDPdxCoarse\"></a><strong>OpDPdxCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>x</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>x</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdxFine\"><strong>OpDPdxFine</strong></a>.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdxCoarse\n\nResult is the partial derivative of P with respect to the window x coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute x derivatives in fewer unique locations than would be allowed for OpDPdxFine.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 181,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpDPdyCoarse",
      "Description": "<a id=\"OpDPdyCoarse\"></a><strong>OpDPdyCoarse</strong><br />\n<br />\nResult is the partial derivative of <em>P</em> with respect to the window <em>y</em> coordinate. Will use local differencing based on the value of <em>P</em> for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of <em>P</em> for the current fragment. That is, over a given area, the implementation can compute <em>y</em> derivatives in fewer unique locations than would be allowed for <a href=\"#OpDPdyFine\"><strong>OpDPdyFine</strong></a>.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpDPdyCoarse\n\nResult is the partial derivative of P with respect to the window y coordinate. Will use local differencing based on the value of P for the current fragment&#8217;s neighbors, and will possibly, but not necessarily, include the value of P for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for OpDPdyFine.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 182,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpFwidthCoarse",
      "Description": "<a id=\"OpFwidthCoarse\"></a><strong>OpFwidthCoarse</strong><br />\n<br />\nResult is the same as computing the sum of the absolute values of <a href=\"#OpDPdxCoarse\"><strong>OpDPdxCoarse</strong></a> and <a href=\"#OpDPdyCoarse\"><strong>OpDPdyCoarse</strong></a> on <em>P</em>.<br />\n<br />\n<em>P</em> is the value to take the derivative of.<br />\n<br />\n<em>Result Type</em> must be the same as the type of <em>P</em>. This type must be a floating-point scalar or floating-point vector.",
      "DescriptionPlain": "OpFwidthCoarse\n\nResult is the same as computing the sum of the absolute values of OpDPdxCoarse and OpDPdyCoarse on P.\n\nP is the value to take the derivative of.\n\nResult Type must be the same as the type of P. This type must be a floating-point scalar or floating-point vector.",
      "Category": "Derivative",
      "Capabilities": [
        "Shader"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 183,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpPhi",
      "Description": "<a id=\"OpPhi\"></a><strong>OpPhi</strong><br />\n<br />\nThe SSA phi function.  Operands are pairs (<em>&lt;id&gt;</em> of variable, <em>&lt;id&gt;</em> of parent block).  All variables must have a type matching <em>Result Type</em>.",
      "DescriptionPlain": "OpPhi\n\nThe SSA phi function.  Operands are pairs (&lt;id&gt; of variable, &lt;id&gt; of parent block).  All variables must have a type matching Result Type.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 48,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Operands",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpLoopMerge",
      "Description": "<a id=\"OpLoopMerge\"></a><strong>OpLoopMerge</strong><br />\n<br />\nDeclare and control a structured control-flow loop construct.<br />\n<br />\n<em>Label</em> is the label of the merge block for this structured loop construct.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
      "DescriptionPlain": "OpLoopMerge\n\nDeclare and control a structured control-flow loop construct.\n\nLabel is the label of the merge block for this structured loop construct.\n\nSee Structured Control Flow for more detail.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 206,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Label",
          "Type": "ID"
        },
        {
          "Name": "LoopControl",
          "Type": "LoopControl"
        }
      ]
    },
    {
      "Name": "OpSelectionMerge",
      "Description": "<a id=\"OpSelectionMerge\"></a><strong>OpSelectionMerge</strong><br />\n<br />\nDeclare and control a structured control-flow selection construct, used with <a href=\"#OpBranchConditional\"><strong>OpBranchConditional</strong></a> or <a href=\"#OpSwitch\"><strong>OpSwitch</strong></a>.<br />\n<br />\n<em>Label</em> is the label of the merge block for this structured selection construct.<br />\n<br />\nSee <a href=\"#StructuredControlFlow\">Structured Control Flow</a> for more detail.",
      "DescriptionPlain": "OpSelectionMerge\n\nDeclare and control a structured control-flow selection construct, used with OpBranchConditional or OpSwitch.\n\nLabel is the label of the merge block for this structured selection construct.\n\nSee Structured Control Flow for more detail.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 207,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Label",
          "Type": "ID"
        },
        {
          "Name": "SelectionControl",
          "Type": "SelectionControl"
        }
      ]
    },
    {
      "Name": "OpLabel",
      "Description": "<a id=\"OpLabel\"></a><strong>OpLabel</strong><br />\n<br />\nThe block label instruction: Any reference to a block is through the <em>Result &lt;id&gt;</em> of its label.<br />\n<br />\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
      "DescriptionPlain": "OpLabel\n\nThe block label instruction: Any reference to a block is through the Result &lt;id&gt; of its label.\n\nMust be the first instruction of any block, and appears only as the first instruction of a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 208,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBranch",
      "Description": "<a id=\"OpBranch\"></a><strong>OpBranch</strong><br />\n<br />\nUnconditional branch to <em>Target Label</em>.<br />\n<br />\n<em>Target Label</em> must be the <em>Result &lt;id&gt;</em> of an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> instruction in the current function.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpBranch\n\nUnconditional branch to Target Label.\n\nTarget Label must be the Result &lt;id&gt; of an OpLabel instruction in the current function.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 209,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "TargetLabel",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBranchConditional",
      "Description": "<a id=\"OpBranchConditional\"></a><strong>OpBranchConditional</strong><br />\n<br />\nIf <em>Condition</em> is <strong>true</strong>, branch to <em>True Label</em>, otherwise branch to <em>False Label</em>.<br />\n<br />\n<em>Condition</em> must be a <a href=\"#Boolean\"><em>Boolean type</em></a> scalar.<br />\n<br />\n<em>True Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>False Label</em> must be an <a href=\"#OpLabel\"><strong>OpLabel</strong></a> in the current function.<br />\n<br />\n<em>Branch weights</em> are unsigned 32-bit integer literals. There must be either no <em>Branch Weights</em> or exactly two branch weights. If present, the first is the weight for branching to <em>True Label</em>, and the second is the weight for branching to <em>False Label</em>. The implied probability that a branch is taken is its weight divided by the sum of the two <em>Branch weights</em>.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpBranchConditional\n\nIf Condition is true, branch to True Label, otherwise branch to False Label.\n\nCondition must be a Boolean type scalar.\n\nTrue Label must be an OpLabel in the current function.\n\nFalse Label must be an OpLabel in the current function.\n\nBranch weights are unsigned 32-bit integer literals. There must be either no Branch Weights or exactly two branch weights. If present, the first is the weight for branching to True Label, and the second is the weight for branching to False Label. The implied probability that a branch is taken is its weight divided by the sum of the two Branch weights.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "4 + variable",
      "WordCountFix": 4,
      "OpCode": 210,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Condition",
          "Type": "ID"
        },
        {
          "Name": "TrueLabel",
          "Type": "ID"
        },
        {
          "Name": "FalseLabel",
          "Type": "ID"
        },
        {
          "Name": "BranchWeights",
          "Type": "LiteralNumber[]"
        }
      ]
    },
    {
      "Name": "OpSwitch",
      "Description": "<a id=\"OpSwitch\"></a><strong>OpSwitch</strong><br />\n<br />\nMulti-way branch to one of the operand label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Selector</em> must be a scalar integer type.  It will be compared for equality to the <em>Target</em> literals.<br />\n<br />\n<em>Default</em> must be the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> does not equal any of the <em>Target</em> literals, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>.<br />\n<br />\n<em>Target</em> must be alternating scalar-integer literals and the <em>&lt;id&gt;</em> of a label.  If <em>Selector</em> equals one of the literals, control flow will branch to the following <em>label &lt;id&gt;</em>. It is invalid for any two <em>Target</em> literals to be equal to each other. If <em>Target</em> is not present, control flow will branch to the <em>Default</em> label <em>&lt;id&gt;</em>.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpSwitch\n\nMulti-way branch to one of the operand label &lt;id&gt;.\n\nSelector must be a scalar integer type.  It will be compared for equality to the Target literals.\n\nDefault must be the &lt;id&gt; of a label.  If Selector does not equal any of the Target literals, control flow will branch to the Default label &lt;id&gt;.\n\nTarget must be alternating scalar-integer literals and the &lt;id&gt; of a label.  If Selector equals one of the literals, control flow will branch to the following label &lt;id&gt;. It is invalid for any two Target literals to be equal to each other. If Target is not present, control flow will branch to the Default label &lt;id&gt;.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3 + variable",
      "WordCountFix": 3,
      "OpCode": 211,
      "HasVariableWordCount": true,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Selector",
          "Type": "ID"
        },
        {
          "Name": "Default",
          "Type": "ID"
        },
        {
          "Name": "Target",
          "Type": "Pair<LiteralNumber,ID>[]"
        }
      ]
    },
    {
      "Name": "OpKill",
      "Description": "<a id=\"OpKill\"></a><strong>OpKill</strong><br />\n<br />\nFragment shader discard.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpKill\n\nFragment shader discard.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [
        "Shader"
      ],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpReturn",
      "Description": "<a id=\"OpReturn\"></a><strong>OpReturn</strong><br />\n<br />\nReturn with no value from a function with void return type.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpReturn\n\nReturn with no value from a function with void return type.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpReturnValue",
      "Description": "<a id=\"OpReturnValue\"></a><strong>OpReturnValue</strong><br />\n<br />\nReturn a value from a function.<br />\n<br />\n<em>Value</em> is the value returned, by copy, and must match the <em>Return Type</em> operand of the <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> type of the <a href=\"#OpFunction\"><strong>OpFunction</strong></a> body this return instruction is in.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpReturnValue\n\nReturn a value from a function.\n\nValue is the value returned, by copy, and must match the Return Type operand of the OpTypeFunction type of the OpFunction body this return instruction is in.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 214,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpUnreachable",
      "Description": "<a id=\"OpUnreachable\"></a><strong>OpUnreachable</strong><br />\n<br />\nDeclares that this block is not reachable in the CFG.<br />\n<br />\nThis instruction must be the last instruction in a block.",
      "DescriptionPlain": "OpUnreachable\n\nDeclares that this block is not reachable in the CFG.\n\nThis instruction must be the last instruction in a block.",
      "Category": "Flow-Control",
      "Capabilities": [
        "Kernel"
      ],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpLifetimeStart",
      "Description": "<a id=\"OpLifetimeStart\"></a><strong>OpLifetimeStart</strong><br />\n<br />\nDeclare that the content of the object pointed to was not defined before this instruction. If <em>Operand 1</em> has a non-void type, <em>Operand 2</em> must be 0, otherwise <em>Operand 2</em> is the amount of memory whose lifetime is starting.",
      "DescriptionPlain": "OpLifetimeStart\n\nDeclare that the content of the object pointed to was not defined before this instruction. If Operand 1 has a non-void type, Operand 2 must be 0, otherwise Operand 2 is the amount of memory whose lifetime is starting.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 216,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Number",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpLifetimeStop",
      "Description": "<a id=\"OpLifetimeStop\"></a><strong>OpLifetimeStop</strong><br />\n<br />\nDeclare that the content of the object pointed to is dead after this instruction. If <em>Operand 1</em> has a non-void type, <em>Operand 2</em> must be 0, otherwise <em>Operand 2</em> is the amount of memory whose life-time is ending.",
      "DescriptionPlain": "OpLifetimeStop\n\nDeclare that the content of the object pointed to is dead after this instruction. If Operand 1 has a non-void type, Operand 2 must be 0, otherwise Operand 2 is the amount of memory whose life-time is ending.",
      "Category": "Flow-Control",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 217,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Object",
          "Type": "ID"
        },
        {
          "Name": "Number",
          "Type": "LiteralNumber"
        }
      ]
    },
    {
      "Name": "OpAtomicInit",
      "Description": "<a id=\"OpAtomicInit\"></a><strong>OpAtomicInit</strong><br />\n<br />\nInitialize atomic memory to <em>Value</em>.  This <em>is not</em> done atomically with respect to anything.<br />\n<br />\nThe type of <em>Value</em> and the type pointed to by <em>Pointer</em> must be the same type.",
      "DescriptionPlain": "OpAtomicInit\n\nInitialize atomic memory to Value.  This is not done atomically with respect to anything.\n\nThe type of Value and the type pointed to by Pointer must be the same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 191,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicLoad",
      "Description": "<a id=\"OpAtomicLoad\"></a><strong>OpAtomicLoad</strong><br />\n<br />\nAtomically load through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\n<em>Result Type</em> must be the same type as the type pointed to by <em>Pointer</em>.",
      "DescriptionPlain": "OpAtomicLoad\n\nAtomically load through Pointer using the given Semantics. All subparts of the value that is loaded will be read atomically with respect to all other atomic accesses to it within Scope.\n\nResult Type must be the same type as the type pointed to by Pointer.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 192,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        }
      ]
    },
    {
      "Name": "OpAtomicStore",
      "Description": "<a id=\"OpAtomicStore\"></a><strong>OpAtomicStore</strong><br />\n<br />\nAtomically store through <em>Pointer</em> using the given <em>Semantics</em>. All subparts of <em>Value</em> will be written atomically with respect to all other atomic accesses to it within <em>Scope</em>.<br />\n<br />\nThe type pointed to by <em>Pointer</em> must be the same type as the type of <em>Value</em>.",
      "DescriptionPlain": "OpAtomicStore\n\nAtomically store through Pointer using the given Semantics. All subparts of Value will be written atomically with respect to all other atomic accesses to it within Scope.\n\nThe type pointed to by Pointer must be the same type as the type of Value.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 193,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicExchange",
      "Description": "<a id=\"OpAtomicExchange\"></a><strong>OpAtomicExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> from copying <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value from copying Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 194,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicCompareExchange",
      "Description": "<a id=\"OpAtomicCompareExchange\"></a><strong>OpAtomicCompareExchange</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicCompareExchange\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 195,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "Comparator",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicCompareExchangeWeak",
      "Description": "<a id=\"OpAtomicCompareExchangeWeak\"></a><strong>OpAtomicCompareExchangeWeak</strong><br />\n<br />\nAttempts to do the following:<br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by selecting <em>Value</em> if <em>Original Value</em> equals <em>Comparator</em> or selecting <em>Original Value</em> otherwise, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type. This type must also match the type of <em>Comparator</em>.<br />\n<br />\nTBD. What is the result if the operation fails?",
      "DescriptionPlain": "OpAtomicCompareExchangeWeak\n\nAttempts to do the following:\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by selecting Value if Original Value equals Comparator or selecting Original Value otherwise, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type. This type must also match the type of Comparator.\n\nTBD. What is the result if the operation fails?",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "8",
      "WordCountFix": 8,
      "OpCode": 196,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "Comparator",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicIIncrement",
      "Description": "<a id=\"OpAtomicIIncrement\"></a><strong>OpAtomicIIncrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer addition of <em>1</em> to <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em> must be the same type as the type pointed to by <em>Pointer</em>.",
      "DescriptionPlain": "OpAtomicIIncrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer addition of 1 to Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type must be the same type as the type pointed to by Pointer.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 197,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        }
      ]
    },
    {
      "Name": "OpAtomicIDecrement",
      "Description": "<a id=\"OpAtomicIDecrement\"></a><strong>OpAtomicIDecrement</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> through integer subtraction of <em>1</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em> must be the same type as the type pointed to by <em>Pointer</em>.",
      "DescriptionPlain": "OpAtomicIDecrement\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value through integer subtraction of 1 from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type must be the same type as the type pointed to by Pointer.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 198,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        }
      ]
    },
    {
      "Name": "OpAtomicIAdd",
      "Description": "<a id=\"OpAtomicIAdd\"></a><strong>OpAtomicIAdd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer addition of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicIAdd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer addition of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 199,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicISub",
      "Description": "<a id=\"OpAtomicISub\"></a><strong>OpAtomicISub</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by integer subtraction of <em>Value</em> from <em>Original Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicISub\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by integer subtraction of Value from Original Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 200,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicUMin",
      "Description": "<a id=\"OpAtomicUMin\"></a><strong>OpAtomicUMin</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the smallest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicUMin\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 201,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicUMax",
      "Description": "<a id=\"OpAtomicUMax\"></a><strong>OpAtomicUMax</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by finding the largest unsigned integer of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicUMax\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 202,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicAnd",
      "Description": "<a id=\"OpAtomicAnd\"></a><strong>OpAtomicAnd</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise AND of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicAnd\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise AND of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 203,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicOr",
      "Description": "<a id=\"OpAtomicOr\"></a><strong>OpAtomicOr</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicOr\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 204,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpAtomicXor",
      "Description": "<a id=\"OpAtomicXor\"></a><strong>OpAtomicXor</strong><br />\n<br />\nPerform the following steps atomically with respect to any other atomic accesses within <em>Scope</em> to the same location: <br />\n1) load through <em>Pointer</em> to get an <em>Original Value</em>,<br />\n2) get a <em>New Value</em> by the bitwise exclusive OR of <em>Original Value</em> and <em>Value</em>, and<br />\n3) store the <em>New Value</em> back through <em>Pointer</em>.<br />\n<br />\nThe instruction&#8217;s result is the <em>Original Value</em>.<br />\n<br />\n<em>Result Type</em>, the type of <em>Value</em>, and the type pointed to by <em>Pointer</em> must all be same type.",
      "DescriptionPlain": "OpAtomicXor\n\nPerform the following steps atomically with respect to any other atomic accesses within Scope to the same location: \n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise exclusive OR of Original Value and Value, and\n3) store the New Value back through Pointer.\n\nThe instruction&#8217;s result is the Original Value.\n\nResult Type, the type of Value, and the type pointed to by Pointer must all be same type.",
      "Category": "Atomic",
      "Capabilities": [],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 205,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Pointer",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEmitVertex",
      "Description": "<a id=\"OpEmitVertex\"></a><strong>OpEmitVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
      "DescriptionPlain": "OpEmitVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nThis instruction can only be used when only one stream is present.",
      "Category": "Primitive",
      "Capabilities": [
        "Geom"
      ],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpEndPrimitive",
      "Description": "<a id=\"OpEndPrimitive\"></a><strong>OpEndPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\nThis instruction can only be used when only one stream is present.",
      "DescriptionPlain": "OpEndPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nThis instruction can only be used when only one stream is present.",
      "Category": "Primitive",
      "Capabilities": [
        "Geom"
      ],
      "HasResult": false,
      "HasResultType": false,
      "Operands": []
    },
    {
      "Name": "OpEmitStreamVertex",
      "Description": "<a id=\"OpEmitStreamVertex\"></a><strong>OpEmitStreamVertex</strong><br />\n<br />\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type.  It is the stream the primitive is on.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
      "DescriptionPlain": "OpEmitStreamVertex\n\nEmits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type.  It is the stream the primitive is on.\n\nThis instruction can only be used when multiple streams are present.",
      "Category": "Primitive",
      "Capabilities": [
        "Geom"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 186,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Stream",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEndStreamPrimitive",
      "Description": "<a id=\"OpEndStreamPrimitive\"></a><strong>OpEndStreamPrimitive</strong><br />\n<br />\nFinish the current primitive and start a new one.  No vertex is emitted.<br />\n<br />\n<em>Stream</em> must be an <em>&lt;id&gt;</em> of a <a href=\"#ConstantInstruction\"><em>constant instruction</em></a> with a scalar integer type.  It is the stream the primitive is on.<br />\n<br />\nThis instruction can only be used when multiple streams are present.",
      "DescriptionPlain": "OpEndStreamPrimitive\n\nFinish the current primitive and start a new one.  No vertex is emitted.\n\nStream must be an &lt;id&gt; of a constant instruction with a scalar integer type.  It is the stream the primitive is on.\n\nThis instruction can only be used when multiple streams are present.",
      "Category": "Primitive",
      "Capabilities": [
        "Geom"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 187,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Stream",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpControlBarrier",
      "Description": "<a id=\"OpControlBarrier\"></a><strong>OpControlBarrier</strong><br />\n<br />\nWait for other invocations of this module to reach this same point of execution.<br />\n<br />\nAll invocations of this module within <em>Scope</em> must reach this point of execution before any will proceed beyond it.<br />\n<br />\nThis instruction is only guaranteed to work correctly if placed strictly within dynamically uniform control flow within <em>Scope</em>. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.<br />\n<br />\nIt is only valid to use this instruction with <strong>Tessellation</strong>, <strong>Compute</strong>, or <strong>Kernel</strong> <a href=\"#Execution Model\">execution models</a>.",
      "DescriptionPlain": "OpControlBarrier\n\nWait for other invocations of this module to reach this same point of execution.\n\nAll invocations of this module within Scope must reach this point of execution before any will proceed beyond it.\n\nThis instruction is only guaranteed to work correctly if placed strictly within dynamically uniform control flow within Scope. This ensures that if any invocation executes it, all invocations will execute it. If placed elsewhere, an invocation may stall indefinitely.\n\nIt is only valid to use this instruction with Tessellation, Compute, or Kernel execution models.",
      "Category": "Barrier",
      "Capabilities": [],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 188,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        }
      ]
    },
    {
      "Name": "OpMemoryBarrier",
      "Description": "<a id=\"OpMemoryBarrier\"></a><strong>OpMemoryBarrier</strong><br />\n<br />\nControl the order that memory accesses are observed.<br />\n<br />\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within <em>Scope</em>.<br />\n<br />\n<em>Semantics</em> declares what kind of memory is being controlled and what kind of control to apply.",
      "DescriptionPlain": "OpMemoryBarrier\n\nControl the order that memory accesses are observed.\n\nEnsures that memory accesses issued before this instruction will be observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within Scope.\n\nSemantics declares what kind of memory is being controlled and what kind of control to apply.",
      "Category": "Barrier",
      "Capabilities": [],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 189,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Semantics",
          "Type": "MemorySemantics"
        }
      ]
    },
    {
      "Name": "OpAsyncGroupCopy",
      "Description": "<a id=\"OpAsyncGroupCopy\"></a><strong>OpAsyncGroupCopy</strong><br />\n<br />\nPerform an asynchronous group copy of <em>Num Elements</em> elements from <em>Source</em> to <em>Destination</em>. The asynchronous copy is performed by all work-items in a group.<br />\n<br />\nReturns an event object that can be used by <a href=\"#OpWaitGroupEvents\"><strong>OpWaitGroupEvents</strong></a> to wait for the copy to finish.<br />\n<br />\n<em>Event</em> must be <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.<br />\n<br />\n<em>Event</em> can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise <em>Event</em> should be a <a href=\"#OpConstantNullObject\"><strong>OpConstantNullObject</strong></a>.<br />\n<br />\nIf <em>Event</em> argument is not <a href=\"#OpConstantNullObject\"><strong>OpConstantNullObject</strong></a>, the event object supplied in event argument will be returned.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>Destination</em> and <em>Source</em> should both be pointers to the same integer or floating point scalar or vector data type.<br />\n<br />\n<em>Destination</em> and <em>Source</em> pointer <a href=\"#Storage Class\"><strong>storage class</strong></a> can be either <strong>WorkgroupLocal</strong> or <strong>WorkgroupGlobal</strong>.<br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage Class\"><strong>storage class</strong></a> is <strong>WorkgroupLocal</strong>, the <em>Source</em> pointer storage class must be <strong>WorkgroupGlobal</strong>. In this case <em>Stride</em> defines the stride in elements when reading from <em>Source</em> pointer.<br />\n<br />\nWhen <em>Destination</em> pointer <a href=\"#Storage Class\"><strong>storage class</strong></a> is <strong>WorkgroupGlobal</strong>, the <em>Source</em> pointer storage class must be <strong>WorkgroupLocal</strong>. In this case <em>Stride</em> defines the stride in elements when writing each element to <em>Destination</em> pointer.<br />\n<br />\n<em>Stride</em> and <em>NumElemens</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical32</strong> and 64 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical64</strong>.",
      "DescriptionPlain": "OpAsyncGroupCopy\n\nPerform an asynchronous group copy of Num Elements elements from Source to Destination. The asynchronous copy is performed by all work-items in a group.\n\nReturns an event object that can be used by OpWaitGroupEvents to wait for the copy to finish.\n\nEvent must be OpTypeEvent.\n\nEvent can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise Event should be a OpConstantNullObject.\n\nIf Event argument is not OpConstantNullObject, the event object supplied in event argument will be returned.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nDestination and Source should both be pointers to the same integer or floating point scalar or vector data type.\n\nDestination and Source pointer storage class can be either WorkgroupLocal or WorkgroupGlobal.\n\nWhen Destination pointer storage class is WorkgroupLocal, the Source pointer storage class must be WorkgroupGlobal. In this case Stride defines the stride in elements when reading from Source pointer.\n\nWhen Destination pointer storage class is WorkgroupGlobal, the Source pointer storage class must be WorkgroupLocal. In this case Stride defines the stride in elements when writing each element to Destination pointer.\n\nStride and NumElemens must be a 32 bit OpTypeInt when the Addressing Model is Physical32 and 64 bit OpTypeInt when the Addressing Model is Physical64.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "9",
      "WordCountFix": 9,
      "OpCode": 219,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Destination",
          "Type": "ID"
        },
        {
          "Name": "Source",
          "Type": "ID"
        },
        {
          "Name": "NumElements",
          "Type": "ID"
        },
        {
          "Name": "Stride",
          "Type": "ID"
        },
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpWaitGroupEvents",
      "Description": "<a id=\"OpWaitGroupEvents\"></a><strong>OpWaitGroupEvents</strong><br />\n<br />\nWait for events generated by <a href=\"#OpAsyncGroupCopy\"><strong>OpAsyncGroupCopy</strong></a> operations to complete. The event objects pointed by <em>Events List</em> will be released after the wait is performed.<br />\n<br />\n<em>Events List</em> must be a pointer to <a href=\"#OpTypeEvent\"><strong>OpTypeEvent</strong></a>.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>Num Events</em> must be a 32 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpWaitGroupEvents\n\nWait for events generated by OpAsyncGroupCopy operations to complete. The event objects pointed by Events List will be released after the wait is performed.\n\nEvents List must be a pointer to OpTypeEvent.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nNum Events must be a 32 bits wide OpTypeInt.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 220,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "EventsList",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupAll",
      "Description": "<a id=\"OpGroupAll\"></a><strong>OpGroupAll</strong><br />\n<br />\nEvaluates a predicate for all work-items in the group,and returns <strong>true</strong> if predicate evaluates to <strong>true</strong> for all work-items in the group, otherwise returns <strong>false</strong>.<br />\n<br />\nBoth the <em>Predicate</em> and the <em>Result Type</em> must be of <a href=\"#OpTypeBool\"><strong>OpTypeBool</strong></a>.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.",
      "DescriptionPlain": "OpGroupAll\n\nEvaluates a predicate for all work-items in the group,and returns true if predicate evaluates to true for all work-items in the group, otherwise returns false.\n\nBoth the Predicate and the Result Type must be of OpTypeBool.\n\nScope must be the Workgroup or Subgroup Execution Scope.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 221,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Predicate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupAny",
      "Description": "<a id=\"OpGroupAny\"></a><strong>OpGroupAny</strong><br />\n<br />\nEvaluates a predicate for all work-items in the group,and returns <strong>true</strong> if predicate evaluates to <strong>true</strong> for any work-item in the group, otherwise returns <strong>false</strong>.<br />\n<br />\nBoth the <em>Predicate</em> and the <em>Result Type</em> must be of <a href=\"#OpTypeBool\"><strong>OpTypeBool</strong></a>.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.",
      "DescriptionPlain": "OpGroupAny\n\nEvaluates a predicate for all work-items in the group,and returns true if predicate evaluates to true for any work-item in the group, otherwise returns false.\n\nBoth the Predicate and the Result Type must be of OpTypeBool.\n\nScope must be the Workgroup or Subgroup Execution Scope.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 222,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Predicate",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupBroadcast",
      "Description": "<a id=\"OpGroupBroadcast\"></a><strong>OpGroupBroadcast</strong><br />\n<br />\nBroadcast a value for workitem identified by the local id to all work-items in the group.<br />\n<br />\n<em>Value</em> and <em>Result Type</em> must be a 32 or 64 bits wise <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>  or a 16, 32 or 64 <a href=\"#OpTypeFloat\"><strong>OpTypeFloat</strong></a> floating-point scalar datatype.<br />\n<br />\n<em>LocalId</em> must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. <em>LocalId</em> must be the same for all work-items in the group.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.",
      "DescriptionPlain": "OpGroupBroadcast\n\nBroadcast a value for workitem identified by the local id to all work-items in the group.\n\nValue and Result Type must be a 32 or 64 bits wise OpTypeInt  or a 16, 32 or 64 OpTypeFloat floating-point scalar datatype.\n\nLocalId must be an integer datatype. It can be a scalar, or a vector with 2 components or a vector with 3 components. LocalId must be the same for all work-items in the group.\n\nScope must be the Workgroup or Subgroup Execution Scope.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 223,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Value",
          "Type": "ID"
        },
        {
          "Name": "LocalId",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupIAdd",
      "Description": "<a id=\"OpGroupIAdd\"></a><strong>OpGroupIAdd</strong><br />\n<br />\nAn integer add group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32 or 64 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is 0.",
      "DescriptionPlain": "OpGroupIAdd\n\nAn integer add group operation specified for all values of X specified by work-items in the group.\n\nX and Result Type must be a 32 or 64 bits wide OpTypeInt data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is 0.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 224,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFAdd",
      "Description": "<a id=\"OpGroupFAdd\"></a><strong>OpGroupFAdd</strong><br />\n<br />\nA floating-point add group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\nBoth <em>X</em> and <em>Result Type</em> must be a 16, 32 or 64 bits wide <a href=\"#OpTypeFloat\"><strong>OpTypeFloat</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is 0.",
      "DescriptionPlain": "OpGroupFAdd\n\nA floating-point add group operation specified for all values of X specified by work-items in the group.\n\nBoth X and Result Type must be a 16, 32 or 64 bits wide OpTypeFloat data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is 0.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 225,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFMin",
      "Description": "<a id=\"OpGroupFMin\"></a><strong>OpGroupFMin</strong><br />\n<br />\nA floating-point minimum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\nBoth <em>X</em> and <em>Result Type</em> must be a 16, 32 or 64 bits wide <a href=\"#OpTypeFloat\"><strong>OpTypeFloat</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is +INF.",
      "DescriptionPlain": "OpGroupFMin\n\nA floating-point minimum group operation specified for all values of X specified by work-items in the group.\n\nBoth X and Result Type must be a 16, 32 or 64 bits wide OpTypeFloat data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is +INF.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 226,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupUMin",
      "Description": "<a id=\"OpGroupUMin\"></a><strong>OpGroupUMin</strong><br />\n<br />\nAn unsigned integer minimum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32 or 64 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is UINT_MAX when <em>X</em> is 32 bits wide and ULONG_MAX when <em>X</em> is 64 bits wide.",
      "DescriptionPlain": "OpGroupUMin\n\nAn unsigned integer minimum group operation specified for all values of X specified by work-items in the group.\n\nX and Result Type must be a 32 or 64 bits wide OpTypeInt data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is UINT_MAX when X is 32 bits wide and ULONG_MAX when X is 64 bits wide.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 227,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupSMin",
      "Description": "<a id=\"OpGroupSMin\"></a><strong>OpGroupSMin</strong><br />\n<br />\nA signed integer minimum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32 or 64 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is INT_MAX when <em>X</em> is 32 bits wide and LONG_MAX when <em>X</em> is 64 bits wide.",
      "DescriptionPlain": "OpGroupSMin\n\nA signed integer minimum group operation specified for all values of X specified by work-items in the group.\n\nX and Result Type must be a 32 or 64 bits wide OpTypeInt data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is INT_MAX when X is 32 bits wide and LONG_MAX when X is 64 bits wide.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 228,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupFMax",
      "Description": "<a id=\"OpGroupFMax\"></a><strong>OpGroupFMax</strong><br />\n<br />\nA floating-point maximum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\nBoth <em>X</em> and <em>Result Type</em> must be a 16, 32 or 64 bits wide <a href=\"#OpTypeFloat\"><strong>OpTypeFloat</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is -INF.",
      "DescriptionPlain": "OpGroupFMax\n\nA floating-point maximum group operation specified for all values of X specified by work-items in the group.\n\nBoth X and Result Type must be a 16, 32 or 64 bits wide OpTypeFloat data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is -INF.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 229,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupUMax",
      "Description": "<a id=\"OpGroupUMax\"></a><strong>OpGroupUMax</strong><br />\n<br />\nAn unsigned integer maximum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32 or 64 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is 0.",
      "DescriptionPlain": "OpGroupUMax\n\nAn unsigned integer maximum group operation specified for all values of X specified by work-items in the group.\n\nX and Result Type must be a 32 or 64 bits wide OpTypeInt data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is 0.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 230,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupSMax",
      "Description": "<a id=\"OpGroupSMax\"></a><strong>OpGroupSMax</strong><br />\n<br />\nA signed integer maximum group operation specified for all values of <em>X</em> specified by work-items in the group.<br />\n<br />\n<em>X</em> and <em>Result Type</em> must be a 32 or 64 bits wide <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> data type.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\nThe identity <em>I</em> is INT_MIN when <em>X</em> is 32 bits wide and LONG_MIN when <em>X</em> is 64 bits wide.",
      "DescriptionPlain": "OpGroupSMax\n\nA signed integer maximum group operation specified for all values of X specified by work-items in the group.\n\nX and Result Type must be a 32 or 64 bits wide OpTypeInt data type.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\nThe identity I is INT_MIN when X is 32 bits wide and LONG_MIN when X is 64 bits wide.",
      "Category": "Group",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 231,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "Operation",
          "Type": "GroupOperation"
        },
        {
          "Name": "X",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEnqueueMarker",
      "Description": "<a id=\"OpEnqueueMarker\"></a><strong>OpEnqueueMarker</strong><br />\n<br />\nEnqueue a marker command to to the queue object specified by <em>q</em>. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in <em>q</em> to complete before the marker completes.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed <em>Wait Events</em> and must be 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> is <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> which gets implictly retained by this instruction.  must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>. If <em>Ret Event</em> is set to null this instruction becomes a no-op.<br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n<br />\nThese are the possible return values:<br />\nA successfull enqueue is indicated by the integer value 0<br />\nA failed enqueue is indicated by the negative integer value -101<br />\n<br />\nWhen running the clCompileProgram or clBuildProgram  with -g flag, the following errors may be returned instead of the negative integer value -101:<br />\n- When <em>q</em> is an invalid queue object, the negative integer value -102 is returned.<br />\n- When <em>Wait Events</em> is null and <em>Num Events</em> &gt; 0, or if <em>Wait Events</em> is not null and <em>Num Events</em> is 0, or if event objects in <em>Wait Events</em> are not valid events, the negative integer value -57 is returned.<br />\n- When the queue object <em>q</em> is full, the negative integer value -161 is returned.<br />\n- When <em>Ret Event</em> is not a null object and an event could not be allocated, the negative integer value -100 is returned.<br />\n- When there is a failure to queue <em>Invoke</em> in the queue <em>q</em> because of insufficient resources needed to execute the kernel, the negative integer value -5 is returned.",
      "DescriptionPlain": "OpEnqueueMarker\n\nEnqueue a marker command to to the queue object specified by q. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in q to complete before the marker completes.\n\nNum Events specifies the number of event objects in the wait list pointed Wait Events and must be 32 bit OpTypeInt treated as unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a OpTypePointer to OpTypeDeviceEvent.\n\nRet Event is OpTypePointer to OpTypeDeviceEvent which gets implictly retained by this instruction.  must be a OpTypePointer to OpTypeDeviceEvent. If Ret Event is set to null this instruction becomes a no-op.\n\nResult Type must be a 32 bit OpTypeInt.\n\nThese are the possible return values:\nA successfull enqueue is indicated by the integer value 0\nA failed enqueue is indicated by the negative integer value -101\n\nWhen running the clCompileProgram or clBuildProgram  with -g flag, the following errors may be returned instead of the negative integer value -101:\n- When q is an invalid queue object, the negative integer value -102 is returned.\n- When Wait Events is null and Num Events &gt; 0, or if Wait Events is not null and Num Events is 0, or if event objects in Wait Events are not valid events, the negative integer value -57 is returned.\n- When the queue object q is full, the negative integer value -161 is returned.\n- When Ret Event is not a null object and an event could not be allocated, the negative integer value -100 is returned.\n- When there is a failure to queue Invoke in the queue q because of insufficient resources needed to execute the kernel, the negative integer value -5 is returned.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 249,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Q",
          "Type": "ID"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "WaitEvents",
          "Type": "ID"
        },
        {
          "Name": "RetEvent",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpEnqueueKernel",
      "Description": "<a id=\"OpEnqueueKernel\"></a><strong>OpEnqueueKernel</strong><br />\n<br />\nEnqueue the the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em> for execution to the queue object specified by <em>q</em>. <br />\n<br />\n<em>ND Range</em> must be a <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Num Events</em> specifies the number of event objects in the wait list pointed <em>Wait Events</em> and must be 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as unsigned integer.<br />\n<br />\n<em>Wait Events</em> specifies the list of wait event objects and must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Ret Event</em> is <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> which gets implictly retained by this instruction.  must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.<br />\n<br />\n<em>Invoke</em> must be a <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> with the following signature:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- Optional list of parameters that must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> storage class.<br />\n<br />\n<em>Param</em> is the first parameter of the function specified by <em>Invoke</em> and must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n<br />\n<em>Param Size</em> is the size in bytes of the memory pointed by <em>Param</em> and must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as unsigned int.<br />\n<br />\n<em>Param Align</em> is the alignment of <em>Param</em>.<br />\n<br />\n<em>Local Size</em> is an optional list of 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> values which are treated as unsigned integers. Every <em>Local Size</em> specifies the size in bytes of the <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> of <em>Invoke</em>.  The number of <em>Local Size</em> operands must match the signature of <em>Invoke</em> <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a><br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>. <br />\n<br />\nThese are the possible return values:<br />\nA successfull enqueue is indicated by the integer value 0<br />\nA failed enqueue is indicated by the negative integer value -101<br />\n<br />\nWhen running the clCompileProgram or clBuildProgram  with -g flag, the following errors may be returned instead of the negative value -101:<br />\n- When <em>q</em> is an invalid queue object, the negative integer value -102 is returned.<br />\n- When <em>ND Range</em> is an invalid descriptor or if the program was compiled with -cl-uniform-work-group-size and the local work size is specified in ndrange but the global work size specified in <em>ND Range</em> is not a multiple of the local work size, the negative integer value -160 is returned.<br />\n- When <em>Wait Events</em> is null and <em>Num Events</em> &gt; 0, or if <em>Wait Events</em> is not null and <em>Num Events</em> is 0, or if event objects in <em>Wait Events</em> are not valid events, the negative integer value -57 is returned.<br />\n- When the queue object <em>q</em> is full, the negative integer value -161 is returned.<br />\n- When one of the operands <em>Local Size</em> is 0, the negative integer value -51 is returned.<br />\n- When <em>Ret Event</em> is not a null object and an event could not be allocated, the negative integer value -100 is returned.<br />\n- When there is a failure to queue <em>Invoke</em> in the queue <em>q</em> because of insufficient resources needed to execute the kernel, the negative integer value -5 is returned.",
      "DescriptionPlain": "OpEnqueueKernel\n\nEnqueue the the function specified by Invoke and the NDRange specified by ND Range for execution to the queue object specified by q. \n\nND Range must be a OpTypeStruct created by OpBuildNDRange.\n\nNum Events specifies the number of event objects in the wait list pointed Wait Events and must be 32 bit OpTypeInt treated as unsigned integer.\n\nWait Events specifies the list of wait event objects and must be a OpTypePointer to OpTypeDeviceEvent.\n\nRet Event is OpTypePointer to OpTypeDeviceEvent which gets implictly retained by this instruction.  must be a OpTypePointer to OpTypeDeviceEvent.\n\nInvoke must be a OpTypeFunction with the following signature:\n- Result Type must be OpTypeVoid.\n- The first parameter must be OpTypePointer to 8 bits OpTypeInt.\n- Optional list of parameters that must be OpTypePointer with WorkgroupLocal storage class.\n\nParam is the first parameter of the function specified by Invoke and must be OpTypePointer to 8 bit OpTypeInt.\n\nParam Size is the size in bytes of the memory pointed by Param and must be a 32 bit OpTypeInt treated as unsigned int.\n\nParam Align is the alignment of Param.\n\nLocal Size is an optional list of 32 bit OpTypeInt values which are treated as unsigned integers. Every Local Size specifies the size in bytes of the OpTypePointer with WorkgroupLocal of Invoke.  The number of Local Size operands must match the signature of Invoke OpTypeFunction\n\nResult Type must be a 32 bit OpTypeInt. \n\nThese are the possible return values:\nA successfull enqueue is indicated by the integer value 0\nA failed enqueue is indicated by the negative integer value -101\n\nWhen running the clCompileProgram or clBuildProgram  with -g flag, the following errors may be returned instead of the negative value -101:\n- When q is an invalid queue object, the negative integer value -102 is returned.\n- When ND Range is an invalid descriptor or if the program was compiled with -cl-uniform-work-group-size and the local work size is specified in ndrange but the global work size specified in ND Range is not a multiple of the local work size, the negative integer value -160 is returned.\n- When Wait Events is null and Num Events &gt; 0, or if Wait Events is not null and Num Events is 0, or if event objects in Wait Events are not valid events, the negative integer value -57 is returned.\n- When the queue object q is full, the negative integer value -161 is returned.\n- When one of the operands Local Size is 0, the negative integer value -51 is returned.\n- When Ret Event is not a null object and an event could not be allocated, the negative integer value -100 is returned.\n- When there is a failure to queue Invoke in the queue q because of insufficient resources needed to execute the kernel, the negative integer value -5 is returned.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "13 + variable",
      "WordCountFix": 13,
      "OpCode": 250,
      "HasVariableWordCount": true,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Q",
          "Type": "ID"
        },
        {
          "Name": "Flags",
          "Type": "KernelEnqueueFlags"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "NumEvents",
          "Type": "ID"
        },
        {
          "Name": "WaitEvents",
          "Type": "ID"
        },
        {
          "Name": "RetEvent",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        },
        {
          "Name": "Param",
          "Type": "ID"
        },
        {
          "Name": "ParamSize",
          "Type": "ID"
        },
        {
          "Name": "ParamAlign",
          "Type": "ID"
        },
        {
          "Name": "Locals",
          "Type": "ID[]"
        }
      ]
    },
    {
      "Name": "OpGetKernelNDrangeSubGroupCount",
      "Description": "<a id=\"OpGetKernelNDrangeSubGroupCount\"></a><strong>OpGetKernelNDrangeSubGroupCount</strong><br />\n<br />\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by <em>ND Range</em> and the function specified by <em>Invoke</em>.<br />\n<br />\n<em>ND Range</em> must be a <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be a <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> with the following signature:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- Optional list of parameters that must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpGetKernelNDrangeSubGroupCount\n\nReturns the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by ND Range and the function specified by Invoke.\n\nND Range must be a OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be a OpTypeFunction with the following signature:\n- Result Type must be OpTypeVoid.\n- The first parameter must be OpTypePointer to 8 bits OpTypeInt.\n- Optional list of parameters that must be OpTypePointer with WorkgroupLocal storage class.\n\nResult Type must be a 32 bit OpTypeInt.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 251,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelNDrangeMaxSubGroupSize",
      "Description": "<a id=\"OpGetKernelNDrangeMaxSubGroupSize\"></a><strong>OpGetKernelNDrangeMaxSubGroupSize</strong><br />\n<br />\nReturns the maximum sub-group size for the function specified by <em>Invoke</em> and the NDRange specified by <em>ND Range</em>. <br />\n<br />\n<em>ND Range</em> must be a <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> created by <a href=\"#OpBuildNDRange\"><strong>OpBuildNDRange</strong></a>.<br />\n<br />\n<em>Invoke</em> must be a <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> with the following signature:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- Optional list of parameters that must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpGetKernelNDrangeMaxSubGroupSize\n\nReturns the maximum sub-group size for the function specified by Invoke and the NDRange specified by ND Range. \n\nND Range must be a OpTypeStruct created by OpBuildNDRange.\n\nInvoke must be a OpTypeFunction with the following signature:\n- Result Type must be OpTypeVoid.\n- The first parameter must be OpTypePointer to 8 bits OpTypeInt.\n- Optional list of parameters that must be OpTypePointer with WorkgroupLocal storage class.\n\nResult Type must be a 32 bit OpTypeInt.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 252,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "NDRange",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelWorkGroupSize",
      "Description": "<a id=\"OpGetKernelWorkGroupSize\"></a><strong>OpGetKernelWorkGroupSize</strong><br />\n<br />\nReturns the maximum work-group size that can be used to execute the function specified by <em>Invoke</em> on the device.<br />\n<br />\n<em>Invoke</em> must be a <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> with the following signature:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- Optional list of parameters that must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpGetKernelWorkGroupSize\n\nReturns the maximum work-group size that can be used to execute the function specified by Invoke on the device.\n\nInvoke must be a OpTypeFunction with the following signature:\n- Result Type must be OpTypeVoid.\n- The first parameter must be OpTypePointer to 8 bits OpTypeInt.\n- Optional list of parameters that must be OpTypePointer with WorkgroupLocal storage class.\n\nResult Type must be a 32 bit OpTypeInt.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 253,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetKernelPreferredWorkGroupSizeMultiple",
      "Description": "<a id=\"OpGetKernelPreferredWorkGroupSizeMultiple\"></a><strong>OpGetKernelPreferredWorkGroupSizeMultiple</strong><br />\n<br />\nReturns the preferred multiple of work-group size for the function specified by <em>Invoke</em>. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue <em>Invoke</em> for execution unless the work-group size specified is larger than the device maximum.<br />\n<br />\n<em>Invoke</em> must be a <a href=\"#OpTypeFunction\"><strong>OpTypeFunction</strong></a> with the following signature:<br />\n- <em>Result Type</em> must be <a href=\"#OpTypeVoid\"><strong>OpTypeVoid</strong></a>.<br />\n- The first parameter must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> to 8 bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.<br />\n- Optional list of parameters that must be <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupLocal</strong></a> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpGetKernelPreferredWorkGroupSizeMultiple\n\nReturns the preferred multiple of work-group size for the function specified by Invoke. This is a performance hint. Specifying a work-group size that is not a multiple of the value returned by this query as the value of the local work size will not fail to enqueue Invoke for execution unless the work-group size specified is larger than the device maximum.\n\nInvoke must be a OpTypeFunction with the following signature:\n- Result Type must be OpTypeVoid.\n- The first parameter must be OpTypePointer to 8 bits OpTypeInt.\n- Optional list of parameters that must be OpTypePointer with WorkgroupLocal storage class.\n\nResult Type must be a 32 bit OpTypeInt.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 254,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Invoke",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpRetainEvent",
      "Description": "<a id=\"OpRetainEvent\"></a><strong>OpRetainEvent</strong><br />\n<br />\nIncrements the reference count of the event object specified by <em>event</em>.<br />\n<br />\n<em>event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
      "DescriptionPlain": "OpRetainEvent\n\nIncrements the reference count of the event object specified by event.\n\nevent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 255,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReleaseEvent",
      "Description": "<a id=\"OpReleaseEvent\"></a><strong>OpReleaseEvent</strong><br />\n<br />\nDecrements the reference count of the event object specified by <em>event</em>. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.<br />\n<br />\n<em>event</em> must be an event that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>, <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a> or <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.",
      "DescriptionPlain": "OpReleaseEvent\n\nDecrements the reference count of the event object specified by event. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.\n\nevent must be an event that was produced by OpEnqueueKernel, OpEnqueueMarker or OpCreateUserEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "2",
      "WordCountFix": 2,
      "OpCode": 256,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCreateUserEvent",
      "Description": "<a id=\"OpCreateUserEvent\"></a><strong>OpCreateUserEvent</strong><br />\n<br />\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).<br />\n<br />\n<em>Result Type</em> must be <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a>.",
      "DescriptionPlain": "OpCreateUserEvent\n\nCreate a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).\n\nResult Type must be OpTypeDeviceEvent.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 257,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsValidEvent",
      "Description": "<a id=\"OpIsValidEvent\"></a><strong>OpIsValidEvent</strong><br />\n<br />\nReturns <em>true</em> if the event specified by <em>event</em> is a valid event, otherwise returns <em>false</em>.<br />\n<br />\n<em>event</em> must be a <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a><br />\n<br />\n<em>Result Type</em> must be a <a href=\"#OpTypeBool\"><strong>OpTypeBool</strong></a>.",
      "DescriptionPlain": "OpIsValidEvent\n\nReturns true if the event specified by event is a valid event, otherwise returns false.\n\nevent must be a OpTypeDeviceEvent\n\nResult Type must be a OpTypeBool.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 258,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Event",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpSetUserEventStatus",
      "Description": "<a id=\"OpSetUserEventStatus\"></a><strong>OpSetUserEventStatus</strong><br />\n<br />\nSets the execution status of a user event specified by <em>event</em>.<em>status</em> can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.<br />\n<br />\n<em>event</em> must be a <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpCreateUserEvent\"><strong>OpCreateUserEvent</strong></a>.<br />\n<br />\n<em>status</em> must be a 32-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> treated as a signed integer.",
      "DescriptionPlain": "OpSetUserEventStatus\n\nSets the execution status of a user event specified by event.status can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.\n\nevent must be a OpTypeDeviceEvent that was produced by OpCreateUserEvent.\n\nstatus must be a 32-bit OpTypeInt treated as a signed integer.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 259,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        },
        {
          "Name": "Status",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCaptureEventProfilingInfo",
      "Description": "<a id=\"OpCaptureEventProfilingInfo\"></a><strong>OpCaptureEventProfilingInfo</strong><br />\n<br />\nCaptures the profiling information specified by <em>info</em> for the command associated with the event specified by <em>event</em> in the memory pointed by <em>value</em>.The profiling information will be available in <em>value</em> once the command identified by <em>event</em> has completed.<br />\n<br />\n<em>event</em> must be a <a href=\"#OpTypeDeviceEvent\"><strong>OpTypeDeviceEvent</strong></a> that was produced by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a> or <a href=\"#OpEnqueueMarker\"><strong>OpEnqueueMarker</strong></a>. <br />\n<br />\nWhen <em>info</em> is <strong>CmdExecTime</strong> <em>value</em> must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with <a href=\"#Storage Class\"><strong>WorkgroupGlobal</strong></a> storage class, to two 64-bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> values. The first 64-bit value describes the elapsed time CL_PROFILING_COMMAND_END - CL_PROFLING_COMMAND_START for the command identified by <em>event</em> in nanoseconds. The second 64-bit value describes the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMAMND_START for the command identified by <em>event</em> in nanoseconds.<br />\n<br />\n<strong>Note:</strong> The behavior of of this instruction is undefined when called multiple times for the same event.",
      "DescriptionPlain": "OpCaptureEventProfilingInfo\n\nCaptures the profiling information specified by info for the command associated with the event specified by event in the memory pointed by value.The profiling information will be available in value once the command identified by event has completed.\n\nevent must be a OpTypeDeviceEvent that was produced by OpEnqueueKernel or OpEnqueueMarker. \n\nWhen info is CmdExecTime value must be a OpTypePointer with WorkgroupGlobal storage class, to two 64-bit OpTypeInt values. The first 64-bit value describes the elapsed time CL_PROFILING_COMMAND_END - CL_PROFLING_COMMAND_START for the command identified by event in nanoseconds. The second 64-bit value describes the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMAMND_START for the command identified by event in nanoseconds.\n\nNote: The behavior of of this instruction is undefined when called multiple times for the same event.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 260,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Event",
          "Type": "ID"
        },
        {
          "Name": "Info",
          "Type": "KernelProfilingInfo"
        },
        {
          "Name": "Value",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetDefaultQueue",
      "Description": "<a id=\"OpGetDefaultQueue\"></a><strong>OpGetDefaultQueue</strong><br />\n<br />\nReturns the default device queue. If a default device queue has not been created, null queue object is returned using the <a href=\"#OpConstantNullObject\"><strong>OpConstantNullObject</strong></a> instruction.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#OpTypeQueue\"><strong>OpTypeQueue</strong></a>.",
      "DescriptionPlain": "OpGetDefaultQueue\n\nReturns the default device queue. If a default device queue has not been created, null queue object is returned using the OpConstantNullObject instruction.\n\nResult Type must be a OpTypeQueue.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 261,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpBuildNDRange",
      "Description": "<a id=\"OpBuildNDRange\"></a><strong>OpBuildNDRange</strong><br />\n<br />\nGiven the global work size specified by <em>GlobalWorkSize</em>, local work size specified by <em>LocalWorkSize</em> and global work offset specified by <em>GlobalWorkOffset</em>, builds a 1D, 2D or 3D ND-range descriptor structure.<br />\n<br />\n<em>GlobalWorkSize</em>, <em>LocalWorkSize</em> and <em>GlobalWorkOffset</em> must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical32</strong> or 64 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical64</strong>.<br />\n<br />\n<em>Result Type</em> is the descriptor and must be a <a href=\"#OpTypeStruct\"><strong>OpTypeStruct</strong></a> with the following ordered list of members, starting from the first to last:<br />\n- 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. <br />\n- <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical32</strong> and 64 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.<br />\n- <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical32</strong> and 64 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical64</strong>. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.<br />\n- <a href=\"#OpTypeArray\"><strong>OpTypeArray</strong></a> with 3 elements, where each element is 32 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical32</strong> and 64 bit <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> when the <strong>Addressing Model</strong> is <strong>Physical64</strong>. This member is an array of an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.",
      "DescriptionPlain": "OpBuildNDRange\n\nGiven the global work size specified by GlobalWorkSize, local work size specified by LocalWorkSize and global work offset specified by GlobalWorkOffset, builds a 1D, 2D or 3D ND-range descriptor structure.\n\nGlobalWorkSize, LocalWorkSize and GlobalWorkOffset must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32 bit OpTypeInt when the Addressing Model is Physical32 or 64 bit OpTypeInt when the Addressing Model is Physical64.\n\nResult Type is the descriptor and must be a OpTypeStruct with the following ordered list of members, starting from the first to last:\n- 32 bit OpTypeInt that specifies the number of dimensions used to specify the global work-items and work-items in the work-group. \n- OpTypeArray with 3 elements, where each element is 32 bit OpTypeInt when the Addressing Model is Physical32 and 64 bit OpTypeInt when the Addressing Model is Physical64. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.\n- OpTypeArray with 3 elements, where each element is 32 bit OpTypeInt when the Addressing Model is Physical32 and 64 bit OpTypeInt when the Addressing Model is Physical64. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that will execute the kernel function.\n- OpTypeArray with 3 elements, where each element is 32 bit OpTypeInt when the Addressing Model is Physical32 and 64 bit OpTypeInt when the Addressing Model is Physical64. This member is an array of an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.",
      "Category": "Device-SideEnqueue",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 262,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "GlobalWorkSize",
          "Type": "ID"
        },
        {
          "Name": "LocalWorkSize",
          "Type": "ID"
        },
        {
          "Name": "GlobalWorkOffset",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReadPipe",
      "Description": "<a id=\"OpReadPipe\"></a><strong>OpReadPipe</strong><br />\n<br />\nRead a packet from the pipe object specified by <em>p</em> into <em>ptr</em>. Returns 0 if the operation is successfull and a negative value if the pipe is empty.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>ptr</em> must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>p</em> and a <strong>Generic</strong> storage class.",
      "DescriptionPlain": "OpReadPipe\n\nRead a packet from the pipe object specified by p into ptr. Returns 0 if the operation is successfull and a negative value if the pipe is empty.\n\np must be a OpTypePipe with ReadOnly Access Qualifier.\n\nptr must be a OpTypePointer with the same data type as p and a Generic storage class.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 234,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Ptr",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpWritePipe",
      "Description": "<a id=\"OpWritePipe\"></a><strong>OpWritePipe</strong><br />\n<br />\nWrite a packet from <em>ptr</em> to the pipe object specified by <em>p</em>. Returns 0 if the operation is successfull and a negative value if the pipe is full.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>ptr</em> must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>p</em> and a <strong>Generic</strong> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpWritePipe\n\nWrite a packet from ptr to the pipe object specified by p. Returns 0 if the operation is successfull and a negative value if the pipe is full.\n\np must be a OpTypePipe with WriteOnly Access Qualifier.\n\nptr must be a OpTypePointer with the same data type as p and a Generic storage class.\n\nResult Type must be a 32-bits OpTypeInt.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 235,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Ptr",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReservedReadPipe",
      "Description": "<a id=\"OpReservedReadPipe\"></a><strong>OpReservedReadPipe</strong><br />\n<br />\nRead a packet from the reserved area specified by <em>reserve_id</em> and <em>index</em> of the pipe object specified by <em>p</em> into <em>ptr</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>num_packets</em> - 1.Returns 0 if the operation is successfull and a negative value otherwise.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>index</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as unsigned value.<br />\n<br />\n<em>ptr</em> must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>p</em> and a <strong>Generic</strong> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpReservedReadPipe\n\nRead a packet from the reserved area specified by reserve_id and index of the pipe object specified by p into ptr. The reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.Returns 0 if the operation is successfull and a negative value otherwise.\n\np must be a OpTypePipe with ReadOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.\n\nindex must be a 32-bits OpTypeInt which is treated as unsigned value.\n\nptr must be a OpTypePointer with the same data type as p and a Generic storage class.\n\nResult Type must be a 32-bits OpTypeInt.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 236,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        },
        {
          "Name": "Ptr",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReservedWritePipe",
      "Description": "<a id=\"OpReservedWritePipe\"></a><strong>OpReservedWritePipe</strong><br />\n<br />\nWrite a packet from <em>ptr</em> into the reserved area specified by <em>reserve_id</em> and <em>index</em> of the pipe object specified by <em>p</em>. The reserved pipe entries are referred to by indices that go from 0 &#8230; <em>num_packets</em> - 1.Returns 0 if the operation is successfull and a negative value otherwise.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>index</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as unsigned value.<br />\n<br />\n<em>ptr</em> must be a <a href=\"#OpTypePointer\"><strong>OpTypePointer</strong></a> with the same data type as <em>p</em> and a <strong>Generic</strong> storage class.<br />\n<br />\n<em>Result Type</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a>.",
      "DescriptionPlain": "OpReservedWritePipe\n\nWrite a packet from ptr into the reserved area specified by reserve_id and index of the pipe object specified by p. The reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.Returns 0 if the operation is successfull and a negative value otherwise.\n\np must be a OpTypePipe with WriteOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.\n\nindex must be a 32-bits OpTypeInt which is treated as unsigned value.\n\nptr must be a OpTypePointer with the same data type as p and a Generic storage class.\n\nResult Type must be a 32-bits OpTypeInt.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "7",
      "WordCountFix": 7,
      "OpCode": 237,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        },
        {
          "Name": "Index",
          "Type": "ID"
        },
        {
          "Name": "Ptr",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReserveReadPipePackets",
      "Description": "<a id=\"OpReserveReadPipePackets\"></a><strong>OpReserveReadPipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for reading from the pipe object specified by <em>p</em>. Returns a valid reservation ID if the reservation is successful.",
      "DescriptionPlain": "OpReserveReadPipePackets\n\nReserve num_packets entries for reading from the pipe object specified by p. Returns a valid reservation ID if the reservation is successful.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 238,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Num_packets",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpReserveWritePipePackets",
      "Description": "<a id=\"OpReserveWritePipePackets\"></a><strong>OpReserveWritePipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for writing to the pipe object specified by <em>p</em>. Returns a valid reservation ID if the reservation is successful.",
      "DescriptionPlain": "OpReserveWritePipePackets\n\nReserve num_packets entries for writing to the pipe object specified by p. Returns a valid reservation ID if the reservation is successful.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "5",
      "WordCountFix": 5,
      "OpCode": 239,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Num_packets",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCommitReadPipe",
      "Description": "<a id=\"OpCommitReadPipe\"></a><strong>OpCommitReadPipe</strong><br />\n<br />\nIndicates that all reads to <em>num_packets</em> associated with the reservation specified by <em>reserve_id</em> and the pipe object specified by <em>p</em> are completed.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpCommitReadPipe\n\nIndicates that all reads to num_packets associated with the reservation specified by reserve_id and the pipe object specified by p are completed.\n\np must be a OpTypePipe with ReadOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 240,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpCommitWritePipe",
      "Description": "<a id=\"OpCommitWritePipe\"></a><strong>OpCommitWritePipe</strong><br />\n<br />\nIndicates that all writes to <em>num_packets</em> associated with the reservation specified by <em>reserve_id</em> and the pipe object specified by <em>p</em> are completed.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpCommitWritePipe\n\nIndicates that all writes to num_packets associated with the reservation specified by reserve_id and the pipe object specified by p are completed.\n\np must be a OpTypePipe with WriteOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "3",
      "WordCountFix": 3,
      "OpCode": 241,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpIsValidReserveId",
      "Description": "<a id=\"OpIsValidReserveId\"></a><strong>OpIsValidReserveId</strong><br />\n<br />\nReturn <strong>true</strong> if <em>reserve_id</em> is a valid reservation ID and <strong>false</strong> otherwise.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#OpTypeBool\"><strong>OpTypeBool</strong></a>.",
      "DescriptionPlain": "OpIsValidReserveId\n\nReturn true if reserve_id is a valid reservation ID and false otherwise.\n\nreserve_id must be a OpTypeReserveId.\n\nResult Type must be a OpTypeBool.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 242,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetNumPipePackets",
      "Description": "<a id=\"OpGetNumPipePackets\"></a><strong>OpGetNumPipePackets</strong><br />\n<br />\nReturns the number of available entries in the pipe object specified by <em>p</em>. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>Result Type</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which should be treated as unsigned value.",
      "DescriptionPlain": "OpGetNumPipePackets\n\nReturns the number of available entries in the pipe object specified by p. The number of available entries in a pipe is a dynamic value.  The value returned should be considered immediately stale.\n\np must be a OpTypePipe with ReadOnly or WriteOnly Access Qualifier.\n\nResult Type must be a 32-bits OpTypeInt which should be treated as unsigned value.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 243,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGetMaxPipePackets",
      "Description": "<a id=\"OpGetMaxPipePackets\"></a><strong>OpGetMaxPipePackets</strong><br />\n<br />\nReturns the maximum number of packets specified when the pipe object specified by <em>p</em> was created.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> or <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>Result Type</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which should be treated as unsigned value.",
      "DescriptionPlain": "OpGetMaxPipePackets\n\nReturns the maximum number of packets specified when the pipe object specified by p was created.\n\np must be a OpTypePipe with ReadOnly or WriteOnly Access Qualifier.\n\nResult Type must be a 32-bits OpTypeInt which should be treated as unsigned value.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 244,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "P",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupReserveReadPipePackets",
      "Description": "<a id=\"OpGroupReserveReadPipePackets\"></a><strong>OpGroupReserveReadPipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for reading from the pipe object specified by <em>p</em> at group level. Returns a valid reservation ID if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>num_packets</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as unsigned value.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpGroupReserveReadPipePackets\n\nReserve num_packets entries for reading from the pipe object specified by p at group level. Returns a valid reservation ID if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\np must be a OpTypePipe with ReadOnly Access Qualifier.\n\nnum_packets must be a 32-bits OpTypeInt which is treated as unsigned value.\n\nResult Type must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 245,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Num_packets",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupReserveWritePipePackets",
      "Description": "<a id=\"OpGroupReserveWritePipePackets\"></a><strong>OpGroupReserveWritePipePackets</strong><br />\n<br />\nReserve <em>num_packets</em> entries for writing to the pipe object specified by <em>p</em> at group level. Returns a valid reservation ID if the reservation is successful.<br />\n<br />\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>num_packets</em> must be a 32-bits <a href=\"#OpTypeInt\"><strong>OpTypeInt</strong></a> which is treated as unsigned value.<br />\n<br />\n<em>Result Type</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpGroupReserveWritePipePackets\n\nReserve num_packets entries for writing to the pipe object specified by p at group level. Returns a valid reservation ID if the reservation is successful.\n\nThe reserved pipe entries are referred to by indices that go from 0 &#8230; num_packets - 1.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\np must be a OpTypePipe with WriteOnly Access Qualifier.\n\nnum_packets must be a 32-bits OpTypeInt which is treated as unsigned value.\n\nResult Type must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "6",
      "WordCountFix": 6,
      "OpCode": 246,
      "HasVariableWordCount": false,
      "HasResult": true,
      "HasResultType": true,
      "Operands": [
        {
          "Name": "ResultType",
          "Type": "ID"
        },
        {
          "Name": "Result",
          "Type": "ID"
        },
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Num_packets",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupCommitReadPipe",
      "Description": "<a id=\"OpGroupCommitReadPipe\"></a><strong>OpGroupCommitReadPipe</strong><br />\n<br />\nA group level indication that all reads to <em>num_packets</em> associated with the reservation specified by <em>reserve_id</em> to the pipe object specified by <em>p</em> are completed.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>ReadOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpGroupCommitReadPipe\n\nA group level indication that all reads to num_packets associated with the reservation specified by reserve_id to the pipe object specified by p are completed.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\np must be a OpTypePipe with ReadOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 247,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        }
      ]
    },
    {
      "Name": "OpGroupCommitWritePipe",
      "Description": "<a id=\"OpGroupCommitWritePipe\"></a><strong>OpGroupCommitWritePipe</strong><br />\n<br />\nA group level indication that all writes to <em>num_packets</em> associated with the reservation specified by <em>reserve_id</em> to the pipe object specified by <em>p</em> are completed.<br />\n<br />\n<em>Scope</em> must be the <strong>Workgroup</strong> or <strong>Subgroup</strong> <a href=\"#Execution Scope\"><strong>Execution Scope</strong></a>.<br />\n<br />\n<em>p</em> must be a <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> with <strong>WriteOnly</strong> <a href=\"#Access Qualifier\"><strong>Access Qualifier</strong></a>.<br />\n<br />\n<em>reserve_id</em> must be a <a href=\"#OpTypeReserveId\"><strong>OpTypeReserveId</strong></a>.",
      "DescriptionPlain": "OpGroupCommitWritePipe\n\nA group level indication that all writes to num_packets associated with the reservation specified by reserve_id to the pipe object specified by p are completed.\n\nScope must be the Workgroup or Subgroup Execution Scope.\n\np must be a OpTypePipe with WriteOnly Access Qualifier.\n\nreserve_id must be a OpTypeReserveId.",
      "Category": "Pipe",
      "Capabilities": [
        "Kernel"
      ],
      "WordCount": "4",
      "WordCountFix": 4,
      "OpCode": 248,
      "HasVariableWordCount": false,
      "HasResult": false,
      "HasResultType": false,
      "Operands": [
        {
          "Name": "Scope",
          "Type": "ExecutionScope"
        },
        {
          "Name": "P",
          "Type": "ID"
        },
        {
          "Name": "Reserve_id",
          "Type": "ID"
        }
      ]
    }
  ],
  "Enums": [
    {
      "Name": "SourceLanguage",
      "Values": [
        {
          "Value": 0,
          "Name": "unknown",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "ESSL",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "GLSL",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "OpenCL",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "The source language is an annotation, with no semantics that effect the meaning of other parts of the module.\nUsed by <a href=\"#OpSource\"><strong>OpSource</strong></a>.",
      "CommentPlain": "The source language is an annotation, with no semantics that effect the meaning of other parts of the module.\nUsed by OpSource."
    },
    {
      "Name": "ExecutionModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Vertex",
          "Comment": "Vertex shading stage.",
          "CommentPlain": "Vertex shading stage.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "TessellationControl",
          "Comment": "Tessellation control (or hull) shading stage.",
          "CommentPlain": "Tessellation control (or hull) shading stage.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "TessellationEvaluation",
          "Comment": "Tessellation evaluation (or domain) shading stage.",
          "CommentPlain": "Tessellation evaluation (or domain) shading stage.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Geometry",
          "Comment": "Geometry shading stage.",
          "CommentPlain": "Geometry shading stage.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Fragment",
          "Comment": "Fragment shading stage.",
          "CommentPlain": "Fragment shading stage.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "GLCompute",
          "Comment": "Graphical compute shading stage.",
          "CommentPlain": "Graphical compute shading stage.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Kernel",
          "Comment": "Compute kernel.",
          "CommentPlain": "Compute kernel.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpEntryPoint\"><strong>OpEntryPoint</strong></a>.",
      "CommentPlain": "Used by OpEntryPoint."
    },
    {
      "Name": "AddressingModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Logical",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Physical32",
          "Comment": "Indicates a 32-bit module, where the address width is equal to 32 bits.",
          "CommentPlain": "Indicates a 32-bit module, where the address width is equal to 32 bits.",
          "Capabilities": [
            "Addr"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Physical64",
          "Comment": "Indicates a 64-bit module, where the address width is equal to 64 bits.",
          "CommentPlain": "Indicates a 64-bit module, where the address width is equal to 64 bits.",
          "Capabilities": [
            "Addr"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpMemoryModel\"><strong>OpMemoryModel</strong></a>.",
      "CommentPlain": "Used by OpMemoryModel."
    },
    {
      "Name": "MemoryModel",
      "Values": [
        {
          "Value": 0,
          "Name": "Simple",
          "Comment": "No shared memory consistency issues.",
          "CommentPlain": "No shared memory consistency issues.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "GLSL450",
          "Comment": "Memory model needed by later versions of GLSL and ESSL.  Works across multiple versions.",
          "CommentPlain": "Memory model needed by later versions of GLSL and ESSL.  Works across multiple versions.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "OpenCL1.2",
          "Comment": "OpenCL 1.2 memory model.",
          "CommentPlain": "OpenCL 1.2 memory model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "OpenCL2.0",
          "Comment": "OpenCL 2.0 memory model.",
          "CommentPlain": "OpenCL 2.0 memory model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "OpenCL2.1",
          "Comment": "OpenCL 2.1 memory model.",
          "CommentPlain": "OpenCL 2.1 memory model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpMemoryModel\"><strong>OpMemoryModel</strong></a>.",
      "CommentPlain": "Used by OpMemoryModel."
    },
    {
      "Name": "ExecutionMode",
      "Values": [
        {
          "Value": 0,
          "Name": "Invocations",
          "Comment": "Number of times to invoke the geometry stage for each input primitive received. The default is to run once for each input primitive. If greater than the target-dependent maximum, it will fail to compile. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Number of times to invoke the geometry stage for each input primitive received. The default is to run once for each input primitive. If greater than the target-dependent maximum, it will fail to compile. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Number of invocations"
            }
          ]
        },
        {
          "Value": 1,
          "Name": "SpacingEqual",
          "Comment": "Requests the tessellation primitive generator to divide edges into a collection of equal-sized segments. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to divide edges into a collection of equal-sized segments. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "SpacingFractionalEven",
          "Comment": "Requests the tessellation primitive generator to divide edges into an even number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to divide edges into an even number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "SpacingFractionalOdd",
          "Comment": "Requests the tessellation primitive generator to divide edges into an odd number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to divide edges into an odd number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "VertexOrderCw",
          "Comment": "Requests the tessellation primitive generator to generate triangles in clockwise order. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to generate triangles in clockwise order. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "VertexOrderCcw",
          "Comment": "Requests the tessellation primitive generator to generate triangles in counter-clockwise order. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to generate triangles in counter-clockwise order. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "PixelCenterInteger",
          "Comment": "Pixels appear centered on whole-number pixel offsets. E.g., the coordinate (0.5, 0.5) appears to move to (0.0, 0.0). Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Pixels appear centered on whole-number pixel offsets. E.g., the coordinate (0.5, 0.5) appears to move to (0.0, 0.0). Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "OriginUpperLeft",
          "Comment": "Pixel coordinates appear to originate in the upper left, and increase toward the right and downward. Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Pixel coordinates appear to originate in the upper left, and increase toward the right and downward. Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "EarlyFragmentTests",
          "Comment": "Fragment tests are to be performed before fragment shader execution. Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Fragment tests are to be performed before fragment shader execution. Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "PointMode",
          "Comment": "Requests the tessellation primitive generator to generate a point for each distinct vertex in the subdivided primitive, rather than to generate lines or triangles. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to generate a point for each distinct vertex in the subdivided primitive, rather than to generate lines or triangles. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "Xfb",
          "Comment": "This stage will run in transform feedback-capturing mode and this module is responsible for describing the transform-feedback setup. See the <strong>XfbBuffer</strong>, <strong>Offset</strong>, and <strong>Stride</strong> <a href=\"#Decoration\"><strong>Decorations</strong></a>.",
          "CommentPlain": "This stage will run in transform feedback-capturing mode and this module is responsible for describing the transform-feedback setup. See the XfbBuffer, Offset, and Stride Decorations.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "DepthReplacing",
          "Comment": "This mode must be declared if this module potentially changes the fragment&#8217;s depth. Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "This mode must be declared if this module potentially changes the fragment&#8217;s depth. Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "DepthAny",
          "Comment": "TBD: this should probably be removed.  Depth testing will always be performed after the shader has executed. Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "TBD: this should probably be removed.  Depth testing will always be performed after the shader has executed. Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "DepthGreater",
          "Comment": "External optimizations may assume depth modifications will leave the fragment&#8217;s depth as greater than or equal to the fragment&#8217;s interpolated depth value (given by the <em>z</em> component of the <strong>FragCoord</strong> <a href=\"#Built-In\"><strong>Built-In</strong></a> decorated variable). Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "External optimizations may assume depth modifications will leave the fragment&#8217;s depth as greater than or equal to the fragment&#8217;s interpolated depth value (given by the z component of the FragCoord Built-In decorated variable). Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "DepthLess",
          "Comment": "External optimizations may assume depth modifications leave the fragment&#8217;s depth less than the fragment&#8217;s interpolated depth value, (given by the <em>z</em> component of the <strong>FragCoord</strong> <a href=\"#Built-In\"><strong>Built-In</strong></a> decorated variable). Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "External optimizations may assume depth modifications leave the fragment&#8217;s depth less than the fragment&#8217;s interpolated depth value, (given by the z component of the FragCoord Built-In decorated variable). Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "DepthUnchanged",
          "Comment": "External optimizations may assume this stage did not modify the fragment&#8217;s depth. However, <strong>DepthReplacing</strong> mode must accurately represent depth modification. Only valid with the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "External optimizations may assume this stage did not modify the fragment&#8217;s depth. However, DepthReplacing mode must accurately represent depth modification. Only valid with the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "LocalSize",
          "Comment": "Indicates the work-group size in the <em>x</em>, <em>y</em>, and <em>z</em> dimensions. Only valid with the <strong>GLCompute</strong> or <strong>Kernel</strong> <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Indicates the work-group size in the x, y, and z dimensions. Only valid with the GLCompute or Kernel Execution Models.",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "x size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "y size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "z size"
            }
          ]
        },
        {
          "Value": 17,
          "Name": "LocalSizeHint",
          "Comment": "A hint to the compiler, which indicates the most likely to be used work-group size in the <em>x</em>, <em>y</em>, and <em>z</em> dimensions. Only valid with the <strong>Kernel</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "A hint to the compiler, which indicates the most likely to be used work-group size in the x, y, and z dimensions. Only valid with the Kernel Execution Model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "x size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "y size"
            },
            {
              "Type": "LiteralNumber",
              "Comment": "z size"
            }
          ]
        },
        {
          "Value": 18,
          "Name": "InputPoints",
          "Comment": "Stage input primitive is <em>points</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage input primitive is points. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "InputLines",
          "Comment": "Stage input primitive is <em>lines</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage input primitive is lines. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "InputLinesAdjacency",
          "Comment": "Stage input primitive is <em>lines adjacency</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage input primitive is lines adjacency. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "InputTriangles",
          "Comment": "For a geometry stage, input primitive is <em>triangles</em>. For a tessellation stage, requests the tessellation primitive generator to generate triangles. Only valid with the <strong>Geometry</strong> or one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "For a geometry stage, input primitive is triangles. For a tessellation stage, requests the tessellation primitive generator to generate triangles. Only valid with the Geometry or one of the tessellation Execution Models.",
          "Capabilities": [
            "Geom",
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "InputTrianglesAdjacency",
          "Comment": "Geometry stage input primitive is <em>triangles adjacency</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Geometry stage input primitive is triangles adjacency. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "InputQuads",
          "Comment": "Requests the tessellation primitive generator to generate <em>quads</em>. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to generate quads. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "InputIsolines",
          "Comment": "Requests the tessellation primitive generator to generate <em>isolines</em>. Only valid with one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Requests the tessellation primitive generator to generate isolines. Only valid with one of the tessellation Execution Models.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "OutputVertices",
          "Comment": "For a geometry stage, the maximum number of vertices the shader will ever emit in a single invocation. For a tessellation-control stage, the number of vertices in the output patch produced by the tessellation control shader, which also specifies the number of times the tessellation control shader is invoked. Only valid with the <strong>Geometry</strong> or one of the tessellation <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "For a geometry stage, the maximum number of vertices the shader will ever emit in a single invocation. For a tessellation-control stage, the number of vertices in the output patch produced by the tessellation control shader, which also specifies the number of times the tessellation control shader is invoked. Only valid with the Geometry or one of the tessellation Execution Models.",
          "Capabilities": [
            "Geom",
            "Tess"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Vertex count"
            }
          ]
        },
        {
          "Value": 26,
          "Name": "OutputPoints",
          "Comment": "Stage output primitive is <em>points</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage output primitive is points. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 27,
          "Name": "OutputLineStrip",
          "Comment": "Stage output primitive is <em>line strip</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage output primitive is line strip. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "OutputTriangleStrip",
          "Comment": "Stage output primitive is <em>triangle strip</em>. Only valid with the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Stage output primitive is triangle strip. Only valid with the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "VecTypeHint",
          "Comment": "A hint to the compiler, which indicates that most operations used in the entry point are explicitly vectorized using a particular vector type. Only valid with the <strong>Kernel</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "A hint to the compiler, which indicates that most operations used in the entry point are explicitly vectorized using a particular vector type. Only valid with the Kernel Execution Model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": [
            {
              "Type": "&lt;id&gt;",
              "Comment": "Vector type"
            }
          ]
        },
        {
          "Value": 30,
          "Name": "ContractionOff",
          "Comment": "Indicates that floating-point-expressions contraction is disallowed. Only valid with the <strong>Kernel</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Indicates that floating-point-expressions contraction is disallowed. Only valid with the Kernel Execution Model.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Declare the modes this module&#8217;s stage will execute in.\nUsed by <a href=\"#OpExecutionMode\"><strong>OpExecutionMode</strong></a>.",
      "CommentPlain": "Declare the modes this module&#8217;s stage will execute in.\nUsed by OpExecutionMode."
    },
    {
      "Name": "StorageClass",
      "Values": [
        {
          "Value": 0,
          "Name": "UniformConstant",
          "Comment": "Shared externally, read-only memory, visible across all instantiations or work groups. Graphics uniform memory.  OpenCL Constant memory.",
          "CommentPlain": "Shared externally, read-only memory, visible across all instantiations or work groups. Graphics uniform memory.  OpenCL Constant memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Input",
          "Comment": "Input from pipeline.  Read only.",
          "CommentPlain": "Input from pipeline.  Read only.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Uniform",
          "Comment": "Shared externally, visible across all instantiations or work groups.",
          "CommentPlain": "Shared externally, visible across all instantiations or work groups.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Output",
          "Comment": "Output to pipeline.",
          "CommentPlain": "Output to pipeline.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "WorkgroupLocal",
          "Comment": "Shared across all work items within a work group. OpenGL \"shared\".  OpenCL local memory.",
          "CommentPlain": "Shared across all work items within a work group. OpenGL \"shared\".  OpenCL local memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "WorkgroupGlobal",
          "Comment": "Visible across all work items of all work groups. OpenCL global memory.",
          "CommentPlain": "Visible across all work items of all work groups. OpenCL global memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "PrivateGlobal",
          "Comment": "Accessible across functions within a module, non-IO (not visible outside the module).",
          "CommentPlain": "Accessible across functions within a module, non-IO (not visible outside the module).",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "Function",
          "Comment": "A variable local to a function.",
          "CommentPlain": "A variable local to a function.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Generic",
          "Comment": "A generic pointer, which overloads StoragePrivate, StorageLocal, StorageGlobal. not a real storage class.",
          "CommentPlain": "A generic pointer, which overloads StoragePrivate, StorageLocal, StorageGlobal. not a real storage class.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Private",
          "Comment": "Private to a work-item and is not visible to another work-item. OpenCL private memory.",
          "CommentPlain": "Private to a work-item and is not visible to another work-item. OpenCL private memory.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "AtomicCounter",
          "Comment": "For holding atomic counters.",
          "CommentPlain": "For holding atomic counters.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Class of storage for declared variables (does not include <a href=\"#Intermediate\"><em>intermediate</em></a> values).\nUsed by:",
      "CommentPlain": "Class of storage for declared variables (does not include intermediate values).\nUsed by:"
    },
    {
      "Name": "Dim",
      "Values": [
        {
          "Value": 0,
          "Name": "1D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "2D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "3D",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Cube",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Rect",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "Buffer",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Dimensionality of a texture.\nUsed by <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a>.",
      "CommentPlain": "Dimensionality of a texture.\nUsed by OpTypeSampler."
    },
    {
      "Name": "SamplerAddressingMode",
      "Values": [
        {
          "Value": 0,
          "Name": "None",
          "Comment": "The image coordinates used to sample elements of the image refer to a location inside the image, otherwise the results are undefined.",
          "CommentPlain": "The image coordinates used to sample elements of the image refer to a location inside the image, otherwise the results are undefined.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "ClampEdge",
          "Comment": "Out-of-range image coordinates are clamped to the extent.",
          "CommentPlain": "Out-of-range image coordinates are clamped to the extent.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Clamp",
          "Comment": "Out-of-range image coordinates will return a border color.",
          "CommentPlain": "Out-of-range image coordinates will return a border color.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "Repeat",
          "Comment": "Out-of-range image coordinates are wrapped to the valid range. Can only be used with normalized coordinates.",
          "CommentPlain": "Out-of-range image coordinates are wrapped to the valid range. Can only be used with normalized coordinates.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "RepeatMirrored",
          "Comment": "Flip the image coordinate at every integer junction. Can only be used with normalized coordinates.",
          "CommentPlain": "Flip the image coordinate at every integer junction. Can only be used with normalized coordinates.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Define the addressing mode of read image extended instructions.",
      "CommentPlain": "Define the addressing mode of read image extended instructions."
    },
    {
      "Name": "SamplerFilterMode",
      "Values": [
        {
          "Value": 16,
          "Name": "Nearest",
          "Comment": "Use filter nearset mode when performing a read image operation.",
          "CommentPlain": "Use filter nearset mode when performing a read image operation.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "Linear",
          "Comment": "Use filter linear mode when performing a read image operation.",
          "CommentPlain": "Use filter linear mode when performing a read image operation.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Define the filter mode of read image extended instructions.",
      "CommentPlain": "Define the filter mode of read image extended instructions."
    },
    {
      "Name": "FPFastMathMode",
      "Values": [
        {
          "Value": 0,
          "Name": "NotNaN",
          "Comment": "Assume parameters and result are not NaN.",
          "CommentPlain": "Assume parameters and result are not NaN.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "NotInf",
          "Comment": "Assume parameters and result are not +/- Inf.",
          "CommentPlain": "Assume parameters and result are not +/- Inf.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "NSZ",
          "Comment": "Treat the sign of a zero parameter or result as insignificant.",
          "CommentPlain": "Treat the sign of a zero parameter or result as insignificant.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "AllowRecip",
          "Comment": "Allow the usage of reciprocal rather than perform a division.",
          "CommentPlain": "Allow the usage of reciprocal rather than perform a division.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Fast",
          "Comment": "Allow algebraic transformations according to real-number associative and distibutive algebra. This flag implies all the others.",
          "CommentPlain": "Allow algebraic transformations according to real-number associative and distibutive algebra. This flag implies all the others.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Enables fast math operations which are otherwise unsafe.",
      "CommentPlain": "Enables fast math operations which are otherwise unsafe."
    },
    {
      "Name": "FPRoundingMode",
      "Values": [
        {
          "Value": 0,
          "Name": "RTE",
          "Comment": "Round to nearest even.",
          "CommentPlain": "Round to nearest even.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "RTZ",
          "Comment": "Round towards zero.",
          "CommentPlain": "Round towards zero.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "RTP",
          "Comment": "Round towards positive infinity.",
          "CommentPlain": "Round towards positive infinity.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "RTN",
          "Comment": "Round towards negative infinity.",
          "CommentPlain": "Round towards negative infinity.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Associate a rounding mode to a floating-point conversion instruction.",
      "CommentPlain": "Associate a rounding mode to a floating-point conversion instruction."
    },
    {
      "Name": "LinkageType",
      "Values": [
        {
          "Value": 0,
          "Name": "Export",
          "Comment": "Accessible by other modules as well.",
          "CommentPlain": "Accessible by other modules as well.",
          "Capabilities": [
            "Link"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Import",
          "Comment": "A declaration for a global identifier that exists in another module.",
          "CommentPlain": "A declaration for a global identifier that exists in another module.",
          "Capabilities": [
            "Link"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Associate a linkage type to functions or global variables. By default, functions and global variables are private to a module and cannot be accessed by other modules.",
      "CommentPlain": "Associate a linkage type to functions or global variables. By default, functions and global variables are private to a module and cannot be accessed by other modules."
    },
    {
      "Name": "AccessQualifier",
      "Values": [
        {
          "Value": 0,
          "Name": "ReadOnly",
          "Comment": "A read-only object.",
          "CommentPlain": "A read-only object.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "WriteOnly",
          "Comment": "A write-only object.",
          "CommentPlain": "A write-only object.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "ReadWrite",
          "Comment": "A readable and writable object.",
          "CommentPlain": "A readable and writable object.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Defines the access permissions of <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a> and <a href=\"#OpTypePipe\"><strong>OpTypePipe</strong></a> object.",
      "CommentPlain": "Defines the access permissions of OpTypeSampler and OpTypePipe object."
    },
    {
      "Name": "FunctionParameterAttribute",
      "Values": [
        {
          "Value": 0,
          "Name": "Zext",
          "Comment": "Value should be zero extended if needed.",
          "CommentPlain": "Value should be zero extended if needed.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Sext",
          "Comment": "Value should be sign extended if needed.",
          "CommentPlain": "Value should be sign extended if needed.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "ByVal",
          "Comment": "This indicates that the pointer parameter should really be passed by value to the function. Only valid for pointer parameters (not for ret value).",
          "CommentPlain": "This indicates that the pointer parameter should really be passed by value to the function. Only valid for pointer parameters (not for ret value).",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Sret",
          "Comment": "Indicates that the pointer parameter specifies the address of a structure that is the return value of the function in the source program. Only applicable to the first parameter which must be a pointer parameters.",
          "CommentPlain": "Indicates that the pointer parameter specifies the address of a structure that is the return value of the function in the source program. Only applicable to the first parameter which must be a pointer parameters.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "NoAlias",
          "Comment": "Indicates that the memory pointed by a pointer parameter is not accessed via pointer values which are not derived from this pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "CommentPlain": "Indicates that the memory pointed by a pointer parameter is not accessed via pointer values which are not derived from this pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "NoCapture",
          "Comment": "The callee does not make a copy of the pointer parameter into a location that is accessible after returning from the callee. Only valid for pointer parameters. Not valid on return values.",
          "CommentPlain": "The callee does not make a copy of the pointer parameter into a location that is accessible after returning from the callee. Only valid for pointer parameters. Not valid on return values.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "SVM",
          "Comment": "CL TBD",
          "CommentPlain": "CL TBD",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "NoWrite",
          "Comment": "Can only read the memory pointed by a pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "CommentPlain": "Can only read the memory pointed by a pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "NoReadWrite",
          "Comment": "Cannot dereference the memory pointed by a pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "CommentPlain": "Cannot dereference the memory pointed by a pointer parameter. Only valid for pointer parameters. Not valid on return values.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Adds additional information to the return type and to each parameter of a function.",
      "CommentPlain": "Adds additional information to the return type and to each parameter of a function."
    },
    {
      "Name": "Decoration",
      "Values": [
        {
          "Value": 0,
          "Name": "PrecisionLow",
          "Comment": "Apply as described in the <a href=\"#ESPrecision\"><strong>ES Precision</strong></a> section.",
          "CommentPlain": "Apply as described in the ES Precision section.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "PrecisionMedium",
          "Comment": "Apply as described in the <a href=\"#ESPrecision\"><strong>ES Precision</strong></a> section.",
          "CommentPlain": "Apply as described in the ES Precision section.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "PrecisionHigh",
          "Comment": "Apply as described in the <a href=\"#ESPrecision\"><strong>ES Precision</strong></a> section.",
          "CommentPlain": "Apply as described in the ES Precision section.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Block",
          "Comment": "Apply to a structure type to establish it is a non-SSBO-like shader-interface block.<br />\n<br />\nTBD can this be removed?  Probably doesn&#8217;t add anything over a nonwritable structure in the <strong>UniformConstant</strong> or <strong>Uniform</strong> storage class. with a <strong>Binding</strong> and <strong>DescriptorSet</strong> decoration.",
          "CommentPlain": "Apply to a structure type to establish it is a non-SSBO-like shader-interface block.\n\nTBD can this be removed?  Probably doesn&#8217;t add anything over a nonwritable structure in the UniformConstant or Uniform storage class. with a Binding and DescriptorSet decoration.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "BufferBlock",
          "Comment": "Apply to a structure type to establish it is an SSBO-like shader-interface block.<br />\n<br />\nTBD can this be removed?  Probably doesn&#8217;t add anything over a structure in the <strong>UniformConstant</strong> or <strong>Uniform</strong> storage class. with a <strong>Binding</strong> and <strong>DescriptorSet</strong> decoration.",
          "CommentPlain": "Apply to a structure type to establish it is an SSBO-like shader-interface block.\n\nTBD can this be removed?  Probably doesn&#8217;t add anything over a structure in the UniformConstant or Uniform storage class. with a Binding and DescriptorSet decoration.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "RowMajor",
          "Comment": "Apply to a variable or a member of a structure.  Must decorate an entity whose type is a matrix. Indicates that components within a row are contiguous in memory.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Must decorate an entity whose type is a matrix. Indicates that components within a row are contiguous in memory.",
          "Capabilities": [
            "Matrix"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "ColMajor",
          "Comment": "Apply to a variable or a member of a structure.  Must decorate an entity whose type is a matrix. Indicates that components within a column are contiguous in memory.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Must decorate an entity whose type is a matrix. Indicates that components within a column are contiguous in memory.",
          "Capabilities": [
            "Matrix"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "GLSLShared",
          "Comment": "Apply to a structure type to get GLSL <strong>shared</strong> memory layout.",
          "CommentPlain": "Apply to a structure type to get GLSL shared memory layout.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "GLSLStd140",
          "Comment": "Apply to a structure type to get GLSL <strong>std140</strong> memory layout.",
          "CommentPlain": "Apply to a structure type to get GLSL std140 memory layout.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "GLSLStd430",
          "Comment": "Apply to a structure type to get GLSL <strong>std430</strong> memory layout.",
          "CommentPlain": "Apply to a structure type to get GLSL std430 memory layout.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "GLSLPacked",
          "Comment": "Apply to a structure type to get GLSL <strong>packed</strong> memory layout.",
          "CommentPlain": "Apply to a structure type to get GLSL packed memory layout.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "Smooth",
          "Comment": "Apply to a variable or a member of a structure.  Indicates that perspective-correct interpolation must be used. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates that perspective-correct interpolation must be used. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "Noperspective",
          "Comment": "Apply to a variable or a member of a structure.  Indicates that linear, non-perspective correct, interpolation must be used. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates that linear, non-perspective correct, interpolation must be used. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "Flat",
          "Comment": "Apply to a variable or a member of a structure.  Indicates no interpolation will be done. The non-interpolated value will come from a vertex, as described in the API specification. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates no interpolation will be done. The non-interpolated value will come from a vertex, as described in the API specification. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "Patch",
          "Comment": "Apply to a variable or a member of a structure. Indicates a tessellation patch. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure. Indicates a tessellation patch. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "Centroid",
          "Comment": "Apply to a variable or a member of a structure. When used with multi-sampling rasterization, allows a single interpolation location for an entire pixel. The interpolation location must lie in both the pixel and in the primitive being rasterized. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure. When used with multi-sampling rasterization, allows a single interpolation location for an entire pixel. The interpolation location must lie in both the pixel and in the primitive being rasterized. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Sample",
          "Comment": "Apply to a variable or a member of a structure. When used with multi-sampling rasterization, requires per-sample interpolation. The interpolation locations must be the locations of the samples lying in both the pixel and in the primitive being rasterized. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure. When used with multi-sampling rasterization, requires per-sample interpolation. The interpolation locations must be the locations of the samples lying in both the pixel and in the primitive being rasterized. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "Invariant",
          "Comment": "Apply to a variable, to indicate expressions computing its value be done invariant with respect to other modules computing the same expressions.",
          "CommentPlain": "Apply to a variable, to indicate expressions computing its value be done invariant with respect to other modules computing the same expressions.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "Restrict",
          "Comment": "Apply to a variable, to indicate the compiler may compile as if there is no aliasing.  See the <a href=\"#AliasingSection\">Aliasing</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the compiler may compile as if there is no aliasing.  See the Aliasing section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "Aliased",
          "Comment": "Apply to a variable, to indicate the compiler is to generate accesses to the variable that work correctly in the presence of aliasing.  See the <a href=\"#AliasingSection\">Aliasing</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the compiler is to generate accesses to the variable that work correctly in the presence of aliasing.  See the Aliasing section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "Volatile",
          "Comment": "Apply to a variable, to indicate the memory holding the variable is volatile.  See the <a href=\"#MemoryModelSection\">Memory Model</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the memory holding the variable is volatile.  See the Memory Model section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "Constant",
          "Comment": "Indicates that a global variable is constant and will <strong>never</strong> be modified. Only allowed on global variables.",
          "CommentPlain": "Indicates that a global variable is constant and will never be modified. Only allowed on global variables.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "Coherent",
          "Comment": "Apply to a variable, to indicate the memory holding the variable is coherent.  See the <a href=\"#MemoryModelSection\">Memory Model</a> section for more detail.",
          "CommentPlain": "Apply to a variable, to indicate the memory holding the variable is coherent.  See the Memory Model section for more detail.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "Nonwritable",
          "Comment": "Apply to a variable, to indicate the memory holding the variable is not writable, and that this module does not write to it.",
          "CommentPlain": "Apply to a variable, to indicate the memory holding the variable is not writable, and that this module does not write to it.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "Nonreadable",
          "Comment": "Apply to a variable, to indicate the memory holding the variable is not readable, and that this module does not read from it.",
          "CommentPlain": "Apply to a variable, to indicate the memory holding the variable is not readable, and that this module does not read from it.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "Uniform",
          "Comment": "Apply to a variable or a member of a structure.  Asserts that the value backing the decorated <em>&lt;id&gt;</em> is dynamically uniform across all instantiations that might run in parallel.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Asserts that the value backing the decorated &lt;id&gt; is dynamically uniform across all instantiations that might run in parallel.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "NoStaticUse",
          "Comment": "Apply to a variable to indicate that it is known that this module does not read or write it.  Useful for establishing interface.<br />\n<br />\nTBD consider removing this?",
          "CommentPlain": "Apply to a variable to indicate that it is known that this module does not read or write it.  Useful for establishing interface.\n\nTBD consider removing this?",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 27,
          "Name": "CPacked",
          "Comment": "Marks a structure type as \"packed\", indicating that the alignment of the structure is one and that there is no padding between structure members.",
          "CommentPlain": "Marks a structure type as \"packed\", indicating that the alignment of the structure is one and that there is no padding between structure members.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "FPSaturatedConversion",
          "Comment": "Indicates that a conversion to an integer type is saturated. Only valid for conversion instructions to integer type.",
          "CommentPlain": "Indicates that a conversion to an integer type is saturated. Only valid for conversion instructions to integer type.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "Stream",
          "Comment": "Apply to a variable or a member of a structure.  Indicates the stream number to put an output on. Only valid for the <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Class</strong></a> and the <strong>Geometry</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates the stream number to put an output on. Only valid for the Output Storage Class and the Geometry Execution Model.",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Stream number"
            }
          ]
        },
        {
          "Value": 30,
          "Name": "Location",
          "Comment": "Apply to a variable or a structure member.  Forms the main linkage for <a href=\"#Storage Class\"><strong>Storage Class</strong></a> <strong>Input</strong> and <strong>Output</strong> variables:<br />\n- between the API and vertex-stage inputs,<br />\n- between consecutive programmable stages, or<br />\n- between fragment-stage outputs and the API.<br />\n Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a structure member.  Forms the main linkage for Storage Class Input and Output variables:\n- between the API and vertex-stage inputs,\n- between consecutive programmable stages, or\n- between fragment-stage outputs and the API.\n Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Location"
            }
          ]
        },
        {
          "Value": 31,
          "Name": "Component",
          "Comment": "Apply to a variable or a member of a structure.  Indicates which component within a <strong>Location</strong> will be taken by the decorated entity. Only valid for the <strong>Input</strong> and <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates which component within a Location will be taken by the decorated entity. Only valid for the Input and Output Storage Classes.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Component within a vector"
            }
          ]
        },
        {
          "Value": 32,
          "Name": "Index",
          "Comment": "Apply to a variable to identify a blend equation input index, used as described in the API specification. Only valid for the <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Class</strong></a> and the <strong>Fragment</strong> <a href=\"#Execution Model\"><strong>Execution Model</strong></a>.",
          "CommentPlain": "Apply to a variable to identify a blend equation input index, used as described in the API specification. Only valid for the Output Storage Class and the Fragment Execution Model.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Index"
            }
          ]
        },
        {
          "Value": 33,
          "Name": "Binding",
          "Comment": "Apply to a variable. Part of the main linkage between the API and SPIR-V modules for memory buffers, textures, etc. See the API specification for more information.",
          "CommentPlain": "Apply to a variable. Part of the main linkage between the API and SPIR-V modules for memory buffers, textures, etc. See the API specification for more information.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Binding point"
            }
          ]
        },
        {
          "Value": 34,
          "Name": "DescriptorSet",
          "Comment": "Apply to a variable. Part of the main linkage between the API and SPIR-V modules for memory buffers, textures, etc. See the API specification for more information.",
          "CommentPlain": "Apply to a variable. Part of the main linkage between the API and SPIR-V modules for memory buffers, textures, etc. See the API specification for more information.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Descriptor set"
            }
          ]
        },
        {
          "Value": 35,
          "Name": "Offset",
          "Comment": "Apply to a structure member.  This gives the byte offset of the member relative to the beginning of the structure. Can be used, for example, by both uniform and transform-feedback buffers.",
          "CommentPlain": "Apply to a structure member.  This gives the byte offset of the member relative to the beginning of the structure. Can be used, for example, by both uniform and transform-feedback buffers.",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Byte offset"
            }
          ]
        },
        {
          "Value": 36,
          "Name": "Alignment",
          "Comment": "TBD: This can probably be removed.",
          "CommentPlain": "TBD: This can probably be removed.",
          "Capabilities": [],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Declared alignment"
            }
          ]
        },
        {
          "Value": 37,
          "Name": "XfbBuffer",
          "Comment": "Apply to a variable or a member of a structure.  Indicates which transform-feedback buffer an output is written to. Only valid for the <strong>Output</strong> <a href=\"#Storage Class\"><strong>Storage Classes</strong></a> of <a href=\"#VertexProcessor\"><em>vertex processing</em></a> <a href=\"#Execution Model\"><strong>Execution Models</strong></a>.",
          "CommentPlain": "Apply to a variable or a member of a structure.  Indicates which transform-feedback buffer an output is written to. Only valid for the Output Storage Classes of vertex processing Execution Models.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "XFB Buffer number"
            }
          ]
        },
        {
          "Value": 38,
          "Name": "Stride",
          "Comment": "The stride, in bytes, of array elements or transform-feedback buffer vertices.",
          "CommentPlain": "The stride, in bytes, of array elements or transform-feedback buffer vertices.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Stride"
            }
          ]
        },
        {
          "Value": 39,
          "Name": "Literal Number",
          "Comment": "See <a href=\"#Built-In\"><strong>Built-In</strong></a>",
          "CommentPlain": "See Built-In",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 40,
          "Name": "FuncParamAttr",
          "Comment": "Indicates a function return value or parameter attribute.",
          "CommentPlain": "Indicates a function return value or parameter attribute.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": [
            {
              "Type": "FunctionParameterAttribute",
              "Comment": "function parameter attribute"
            }
          ]
        },
        {
          "Value": 41,
          "Name": "FP Rounding Mode",
          "Comment": "Indicates a floating-point rounding mode.",
          "CommentPlain": "Indicates a floating-point rounding mode.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": [
            {
              "Type": "FPRoundingMode",
              "Comment": "floating-point rounding mode"
            }
          ]
        },
        {
          "Value": 42,
          "Name": "FP Fast Math Mode",
          "Comment": "Indicates a floating-point fast math flag.",
          "CommentPlain": "Indicates a floating-point fast math flag.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": [
            {
              "Type": "FPFastMathMode",
              "Comment": "fast-math mode"
            }
          ]
        },
        {
          "Value": 43,
          "Name": "Linkage Type",
          "Comment": "Indicate a linkage type. Only valid on an <a href=\"#OpFunction\"><strong>OpFunction</strong></a> or a module scope <a href=\"#OpVariable\"><strong>OpVariable</strong></a>.",
          "CommentPlain": "Indicate a linkage type. Only valid on an OpFunction or a module scope OpVariable.",
          "Capabilities": [
            "Link"
          ],
          "ExtraOperands": [
            {
              "Type": "LinkageType",
              "Comment": "linkage type"
            }
          ]
        },
        {
          "Value": 44,
          "Name": "SpecId",
          "Comment": "Apply to a specialization constant. Forms the API linkage for setting a specialized value. See <a href=\"#SpecializationSection\">specialization</a>.",
          "CommentPlain": "Apply to a specialization constant. Forms the API linkage for setting a specialized value. See specialization.",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": [
            {
              "Type": "LiteralNumber",
              "Comment": "Specialization Constant ID"
            }
          ]
        }
      ],
      "Comment": "Used by <a href=\"#OpDecorate\"><strong>OpDecorate</strong></a> and <a href=\"#OpMemberDecorate\"><strong>OpMemberDecorate</strong></a>.",
      "CommentPlain": "Used by OpDecorate and OpMemberDecorate."
    },
    {
      "Name": "Built-In",
      "Values": [
        {
          "Value": 0,
          "Name": "Position",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "PointSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "ClipVertex",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "ClipDistance",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "CullDistance",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 5,
          "Name": "VertexId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 6,
          "Name": "InstanceId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 7,
          "Name": "PrimitiveId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Geom",
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "InvocationId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Geom",
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 9,
          "Name": "Layer",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 10,
          "Name": "ViewportIndex",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Geom"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 11,
          "Name": "TessLevelOuter",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 12,
          "Name": "TessLevelInner",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 13,
          "Name": "TessCoord",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 14,
          "Name": "PatchVertices",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Tess"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 15,
          "Name": "FragCoord",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "PointCoord",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 17,
          "Name": "FrontFacing",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 18,
          "Name": "SampleId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 19,
          "Name": "SamplePosition",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 20,
          "Name": "SampleMask",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 21,
          "Name": "FragColor",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 22,
          "Name": "FragDepth",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 23,
          "Name": "HelperInvocation",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 24,
          "Name": "NumWorkgroups",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 25,
          "Name": "WorkgroupSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 26,
          "Name": "WorkgroupId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 27,
          "Name": "LocalInvocationId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 28,
          "Name": "GlobalInvocationId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 29,
          "Name": "LocalInvocationIndex",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Shader"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 30,
          "Name": "WorkDim",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 31,
          "Name": "GlobalSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "EnqueuedWorkgroupSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 33,
          "Name": "GlobalOffset",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 34,
          "Name": "GlobalLinearId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 35,
          "Name": "WorkgroupLinearId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 36,
          "Name": "SubgroupSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 37,
          "Name": "SubgroupMaxSize",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 38,
          "Name": "NumSubgroups",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 39,
          "Name": "NumEnqueuedSubgroups",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 40,
          "Name": "SubgroupId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 41,
          "Name": "SubgroupLocalInvocationId",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used when <a href=\"#Decoration\"><strong>Decoration</strong></a> is <strong>Built-In</strong>. Apply to either",
      "CommentPlain": "Used when Decoration is Built-In. Apply to either"
    },
    {
      "Name": "SelectionControl",
      "Values": [
        {
          "Value": 0,
          "Name": "NoControl",
          "Comment": "No control requested.",
          "CommentPlain": "No control requested.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Flatten",
          "Comment": "Strong request, to the extent possible, to remove the flow control for this selection.",
          "CommentPlain": "Strong request, to the extent possible, to remove the flow control for this selection.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontFlatten",
          "Comment": "Strong request, to the extent possible, to keep this selection as flow control.",
          "CommentPlain": "Strong request, to the extent possible, to keep this selection as flow control.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpSelectionMerge\"><strong>OpSelectionMerge</strong></a>.",
      "CommentPlain": "Used by OpSelectionMerge."
    },
    {
      "Name": "LoopControl",
      "Values": [
        {
          "Value": 0,
          "Name": "NoControl",
          "Comment": "No control requested.",
          "CommentPlain": "No control requested.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Unroll",
          "Comment": "Strong request, to the extent possible, to unroll or unwind this loop.",
          "CommentPlain": "Strong request, to the extent possible, to unroll or unwind this loop.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontUnroll",
          "Comment": "Strong request, to the extent possible, to keep this loop as a loop, without unrolling.",
          "CommentPlain": "Strong request, to the extent possible, to keep this loop as a loop, without unrolling.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpLoopMerge\"><strong>OpLoopMerge</strong></a>.",
      "CommentPlain": "Used by OpLoopMerge."
    },
    {
      "Name": "FunctionControlMask",
      "Values": [
        {
          "Value": 1,
          "Name": "InLine",
          "Comment": "Strong request, to the extent possible, to inline the function.",
          "CommentPlain": "Strong request, to the extent possible, to inline the function.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "DontInline",
          "Comment": "Strong request, to the extent possible, to not inline the function.",
          "CommentPlain": "Strong request, to the extent possible, to not inline the function.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Pure",
          "Comment": "Compiler can assume this function has no side effect, but might read global memory or read through dereferenced function parameters. Always computes the same result for the same argument values.",
          "CommentPlain": "Compiler can assume this function has no side effect, but might read global memory or read through dereferenced function parameters. Always computes the same result for the same argument values.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Const",
          "Comment": "Compiler can assume this function has no side effects, and will not access global memory or dereference function parameters. Always computes the same result for the same argument values.",
          "CommentPlain": "Compiler can assume this function has no side effects, and will not access global memory or dereference function parameters. Always computes the same result for the same argument values.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Used by <a href=\"#OpFunction\"><strong>OpFunction</strong></a>.",
      "CommentPlain": "Used by OpFunction."
    },
    {
      "Name": "MemorySemantics",
      "Values": [
        {
          "Value": 1,
          "Name": "Relaxed",
          "Comment": "TBD",
          "CommentPlain": "TBD",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Sequentially-Consistent",
          "Comment": "All observers will see this memory access in the same order WRT to other sequentially-consistent memory accesses from this invocation.",
          "CommentPlain": "All observers will see this memory access in the same order WRT to other sequentially-consistent memory accesses from this invocation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 4,
          "Name": "Acquire",
          "Comment": "All memory operations provided in program order after this memory operation will execute after this memory operation.",
          "CommentPlain": "All memory operations provided in program order after this memory operation will execute after this memory operation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 8,
          "Name": "Release",
          "Comment": "All memory operations provided in program order before this memory operation will execute before this memory operation.",
          "CommentPlain": "All memory operations provided in program order before this memory operation will execute before this memory operation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 16,
          "Name": "Uniform-memory",
          "Comment": "Filter the memory operations being constrained to just those accessing <strong>Uniform</strong> <a href=\"#Storage Class\"><strong>Storage Class</strong></a> memory.",
          "CommentPlain": "Filter the memory operations being constrained to just those accessing Uniform Storage Class memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 32,
          "Name": "Subgroup-memory",
          "Comment": "The memory semantics only have to be correct WRT to this invocation&#8217;s subgroup memory.",
          "CommentPlain": "The memory semantics only have to be correct WRT to this invocation&#8217;s subgroup memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 64,
          "Name": "Workgroup-local-memory",
          "Comment": "The memory semantics only have to be correct WRT to this invocation&#8217;s local workgroup memory.",
          "CommentPlain": "The memory semantics only have to be correct WRT to this invocation&#8217;s local workgroup memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 128,
          "Name": "Workgroup-global-memory",
          "Comment": "The memory semantics only have to be correct WRT to this invocation&#8217;s global workgroup memory.",
          "CommentPlain": "The memory semantics only have to be correct WRT to this invocation&#8217;s global workgroup memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 256,
          "Name": "Atomic-counter-memory",
          "Comment": "Filter the memory operations being constrained to just those accessing <strong>AtomicCounter</strong> <a href=\"#Storage Class\"><strong>Storage Class</strong></a> memory.",
          "CommentPlain": "Filter the memory operations being constrained to just those accessing AtomicCounter Storage Class memory.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 512,
          "Name": "Image-memory",
          "Comment": "Filter the memory operations being constrained to just those accessing images (see <a href=\"#OpTypeSampler\"><strong>OpTypeSampler</strong></a> <em>Content</em>).",
          "CommentPlain": "Filter the memory operations being constrained to just those accessing images (see OpTypeSampler Content).",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Memory classification and ordering semantics.\nUsed by:",
      "CommentPlain": "Memory classification and ordering semantics.\nUsed by:"
    },
    {
      "Name": "MemoryAccess",
      "Values": [
        {
          "Value": 1,
          "Name": "Volatile",
          "Comment": "This access cannot be optimized away; it has to be executed.",
          "CommentPlain": "This access cannot be optimized away; it has to be executed.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Aligned",
          "Comment": "This access has a known alignment, provided as a literal in the next operand.",
          "CommentPlain": "This access has a known alignment, provided as a literal in the next operand.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Memory access semantics.",
      "CommentPlain": "Memory access semantics."
    },
    {
      "Name": "ExecutionScope",
      "Values": [
        {
          "Value": 0,
          "Name": "CrossDevice",
          "Comment": "Everything executing on all the execution devices in the system.",
          "CommentPlain": "Everything executing on all the execution devices in the system.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "Device",
          "Comment": "Everything executing on the device executing this invocation.",
          "CommentPlain": "Everything executing on the device executing this invocation.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "Workgroup",
          "Comment": "All invocations for the invoking workgroup.",
          "CommentPlain": "All invocations for the invoking workgroup.",
          "Capabilities": [],
          "ExtraOperands": []
        },
        {
          "Value": 3,
          "Name": "Subgroup",
          "Comment": "All invocations in the currently executing subgroup.",
          "CommentPlain": "All invocations in the currently executing subgroup.",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Scope of execution.\nUsed by:",
      "CommentPlain": "Scope of execution.\nUsed by:"
    },
    {
      "Name": "GroupOperation",
      "Values": [
        {
          "Value": 0,
          "Name": "Reduce",
          "Comment": "Returns the result of a reduction operation for all values of a specific value X specified by workitems within a workgroup.",
          "CommentPlain": "Returns the result of a reduction operation for all values of a specific value X specified by workitems within a workgroup.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "InclusiveScan",
          "Comment": "The inclusive scan performs a binary operation with an identity <em>I</em> and <em>n</em> (where <em>n</em> is the size of the workgroup) elements[<em>a<sub>0</sub></em>, <em>a<sub>1</sub></em>, &#8230; <em>a<sub>n-1</sub></em>] and returns [<em>a<sub>0</sub></em>, (<em>a<sub>0</sub></em> op <em>a<sub>1</sub></em>), &#8230;(<em>a<sub>0</sub></em> op <em>a<sub>1</sub></em> op &#8230; op <em>a<sub>n-1</sub></em>)]",
          "CommentPlain": "The inclusive scan performs a binary operation with an identity I and n (where n is the size of the workgroup) elements[a0, a1, &#8230; an-1] and returns [a0, (a0 op a1), &#8230;(a0 op a1 op &#8230; op an-1)]",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "ExclusiveScan",
          "Comment": "The exclusive scan performs a binary operation with an identity <em>I</em> and <em>n</em> (where <em>n</em> is the size of the workgroup) elements[<em>a<sub>0</sub></em>, <em>a<sub>1</sub></em>, &#8230; <em>a<sub>n-1</sub></em>] and returns [<em>I</em>, <em>a<sub>0</sub></em>, (<em>a<sub>0</sub></em> op <em>a<sub>1</sub></em>), &#8230; (<em>a<sub>0</sub></em> op <em>a<sub>1</sub></em> op &#8230; op <em>a<sub>n-2</sub></em>)].",
          "CommentPlain": "The exclusive scan performs a binary operation with an identity I and n (where n is the size of the workgroup) elements[a0, a1, &#8230; an-1] and returns [I, a0, (a0 op a1), &#8230; (a0 op a1 op &#8230; op an-2)].",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Defines the class of workgroup or subgroup operation.\nUsed by:",
      "CommentPlain": "Defines the class of workgroup or subgroup operation.\nUsed by:"
    },
    {
      "Name": "KernelEnqueueFlags",
      "Values": [
        {
          "Value": 0,
          "Name": "NoWait",
          "Comment": "Indicates that the enqueued kernels do not need to wait for the parent kernel to finish execution before they begin execution.",
          "CommentPlain": "Indicates that the enqueued kernels do not need to wait for the parent kernel to finish execution before they begin execution.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 1,
          "Name": "WaitKernel",
          "Comment": "Indicates that all work-items of the parent kernel must finish executing and all immediate side effects committed before the enqueued child kernel may begin execution.<br />\n<br />\n<strong>Note:</strong> Immediate meaning not side effects resulting from child kernels. The side effects would include stores to global memory and pipe reads and writes.",
          "CommentPlain": "Indicates that all work-items of the parent kernel must finish executing and all immediate side effects committed before the enqueued child kernel may begin execution.\n\nNote: Immediate meaning not side effects resulting from child kernels. The side effects would include stores to global memory and pipe reads and writes.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        },
        {
          "Value": 2,
          "Name": "WaitWorkGroup",
          "Comment": "Indicates that the enqueued kernels wait only for the workgroup that enqueued the kernels to finish before they begin execution.<br />\n<br />\n<strong>Note:</strong> This acts as a memory synchronization point between work-items in a work-group and child kernels enqueued by work-items in the work-group.",
          "CommentPlain": "Indicates that the enqueued kernels wait only for the workgroup that enqueued the kernels to finish before they begin execution.\n\nNote: This acts as a memory synchronization point between work-items in a work-group and child kernels enqueued by work-items in the work-group.",
          "Capabilities": [
            "Kernel"
          ],
          "ExtraOperands": []
        }
      ],
      "Comment": "Specify when the child kernel begins execution.<br />\n<br />\n<strong>Note:</strong> Implementations are not required to honor this flag.  Implementations may not schedule kernel launch earlier than the point specified by this flag, however.\nUsed by <a href=\"#OpEnqueueKernel\"><strong>OpEnqueueKernel</strong></a>.",
      "CommentPlain": "Specify when the child kernel begins execution.\n\nNote: Implementations are not required to honor this flag.  Implementations may not schedule kernel launch earlier than the point specified by this flag, however.\nUsed by OpEnqueueKernel."
    },
    {
      "Name": "KernelProfilingInfo",
      "Values": [
        {
          "Value": 1,
          "Name": "CmdExecTime",
          "Comment": "",
          "CommentPlain": "",
          "Capabilities": [],
          "ExtraOperands": []
        }
      ],
      "Comment": "Specify the profiling information to be queried.\nUsed by <a href=\"#OpCaptureEventProfilingInfo\"><strong>OpCaptureEventProfilingInfo</strong></a>.",
      "CommentPlain": "Specify the profiling information to be queried.\nUsed by OpCaptureEventProfilingInfo."
    }
  ]
}